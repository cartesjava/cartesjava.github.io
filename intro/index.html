<!doctype html><html lang=fr-ca dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Introduction # Dans ce manuel, nous proposons une approche pour enseigner la programmation avec des cartes à jouer. Les étudiant·e·s seront invité·es à réaliser une procédure informatique avec des cartes, avant de programmer cette procédure en Java et, puis de valider leur code à l&rsquo;aide d&rsquo;un logiciel créé spécifiquement pour accompagner ce manuel.
Nous utilisons ensuite cette approche pour expliquer les notions d&rsquo;efficacité (complexité des algorithmes) et de structure de données (en particulier les listes, les arbres et les mappages)."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Introduction"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://cartesjava.github.io/intro/"><title>Introduction</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.da239a9db90e469c926fac401bc6371530fa393cf5080e3949268e5d1457d223.css integrity="sha256-2iOanbkORpySb6xAG8Y3FTD6OTz1CA45SSaOXRRX0iM=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/fr.search.min.e2f79d9cdd65d269cbf60a3964e3403af9612e86240ea59270588d8d87b6f624.js integrity="sha256-4vednN1l0mnL9go5ZONAOvlhLoYkDqWScFiNjYe29iQ=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<script defer src=/reload_videos.min.d953a2935c293613a48c1b87d70724f50a30888a3391a0a6394f345873051158.js integrity="sha256-2VOik1wpNhOkjBuH1wck9QowiIozkaCmOU80WHMFEVg=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=https://cartesjava.github.io/intro/index.xml title="Cartes Java"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Cartes Java</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/preface/>Préface</a><ul></ul></li><li><a href=/intro/ class=active>Introduction</a><ul></ul></li><li><input type=checkbox id=section-b1f25d69250e7772af5811e7ef44e922 class=toggle>
<label for=section-b1f25d69250e7772af5811e7ef44e922 class="flex justify-between"><a href=/approche/>1. Présentation de l'approche</a></label><ul><li><a href=/approche/outil/>1.1. Outil de validation</a><ul></ul></li><li><a href=/approche/langages_et_notations/>1.2. Langages et notations utilisées</a><ul></ul></li><li><a href=/approche/cartes_a_jouer/>1.3. Visualisations avec des cartes à jouer</a><ul></ul></li></ul></li><li><input type=checkbox id=section-20d2db300e0f4ab0130280f200c4f2fc class=toggle>
<label for=section-20d2db300e0f4ab0130280f200c4f2fc class="flex justify-between"><a href=/modelisation/>2. Modélisation des données et limitations de l'approche</a></label><ul><li><a href=/modelisation/objets/>2.1. Objets</a><ul></ul></li><li><a href=/modelisation/tableau_d_objets/>2.2. Tableaux d'objets</a><ul></ul></li><li><a href=/modelisation/graphes_d_objets/>2.3. Graphes d'objets</a><ul></ul></li></ul></li><li><input type=checkbox id=section-89a3727667e5590a4150c67be9175eaa class=toggle>
<label for=section-89a3727667e5590a4150c67be9175eaa class="flex justify-between"><span class=disabled>3. Qu'est-ce que l'efficacité?</a></label><ul><li><span class=disabled>3.1. Performance Vs efficacité
<span class=disabled><ul></ul></li><li><span class=disabled>3.2. Efficacité en temps
<span class=disabled><ul></ul></li><li><span class=disabled>3.3. Efficacité en espace
<span class=disabled><ul></ul></li></ul></li><li><input type=checkbox id=section-b12c28f0f1b1687a56347184fa5203f8 class=toggle>
<label for=section-b12c28f0f1b1687a56347184fa5203f8 class="flex justify-between"><span class=disabled>4. Comprendre les listes</a></label><ul><li><span class=disabled>4.1. Liste naïve
<span class=disabled><ul></ul></li><li><span class=disabled>4.2. Liste par tableau
<span class=disabled><ul></ul></li><li><span class=disabled>4.3. Liste chaînée simple
<span class=disabled><ul></ul></li><li><span class=disabled>4.4. Liste chaînée double
<span class=disabled><ul></ul></li></ul></li><li><input type=checkbox id=section-4d776affa1be45887905ae21b1d04b2a class=toggle>
<label for=section-4d776affa1be45887905ae21b1d04b2a class="flex justify-between"><span class=disabled>5. Comprendre les arbres</a></label><ul><li><span class=disabled>5.1. Arbre générique
<span class=disabled></li><li><span class=disabled>5.2. Arbre binaire
<span class=disabled></li></ul></li><li><input type=checkbox id=section-3e48974585d14c8908a67306d3ef0b3b class=toggle>
<label for=section-3e48974585d14c8908a67306d3ef0b3b class="flex justify-between"><span class=disabled>6. Comprendre les mappages</a></label><ul><li><span class=disabled>6.1. Mappage naïf
<span class=disabled><ul></ul></li><li><span class=disabled>6.2. Mappage par hachage
<span class=disabled><ul></ul></li><li><span class=disabled>6.3. Mappage avec arbre
<span class=disabled><ul></ul></li></ul></li><li><span class=disabled>Conclusion
<span class=disabled></li><li><a href=/bibliographie/>Bibliographie</a><ul></ul></li><li><input type=checkbox id=section-9ea2d72b97e9d02a8b97ae9357b7969b class=toggle>
<label for=section-9ea2d72b97e9d02a8b97ae9357b7969b class="flex justify-between"><a role=button>Annexes</a></label><ul><li><a href=/annexes/annexe_grand_o/>Annexe 1: la notation grand O</a><ul></ul></li><li><a href=/annexes/annexe_acceder_exemples/>Annexe 2: accéder aux exemples</a><ul></ul></li><li><a href=/annexes/annexe_programmer_exemple/>Annexe 3: programmer un nouvel exemple</a><ul></ul></li><li><a href=/annexes/annexe_modifier_manuel/>Annexe 4: suggérer une modification à ce manuel</a><ul></ul></li><li><input type=checkbox id=section-3b1da941c278c90106392151b814a2c6 class=toggle>
<label for=section-3b1da941c278c90106392151b814a2c6 class="flex justify-between"><a href=/annexes/annexe_ateliers/>Annexe 5: exemples d'ateliers</a></label><ul><li><a href=/annexes/annexe_ateliers/deplacer_decaler/>Procédures déplacer/décaler</a><ul></ul></li><li><a href=/annexes/annexe_ateliers/fibonacci/>Modéliser la suite de Fibonacci</a><ul></ul></li><li><span class=disabled>Liste par tableau
<span class=disabled><ul></ul></li><li><span class=disabled>Arbre binaire
<span class=disabled><ul></ul></li></ul></li><li><input type=checkbox id=section-47be0624d93c2dddef9d700a6ef60a09 class=toggle>
<label for=section-47be0624d93c2dddef9d700a6ef60a09 class="flex justify-between"><a href=/annexes/annexe_bilans/>Annexe 6: bilans</a></label><ul><li><a href=/annexes/annexe_bilans/bilan_juin_2022/>Bilan juin 2022</a></li><li><a href=/annexes/annexe_bilans/bilan_octobre_2022/>Bilan octobre 2022</a><ul></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page-and-footer><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Introduction</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><ul><li><a href=#%c3%a0-qui-sadresse-ce-manuelnbsp>À qui s&rsquo;adresse ce manuel ?</a></li></ul><ul><li><a href=#pourquoi-utiliser-des-cartes-%c3%a0-jouernbsp>Pourquoi utiliser des cartes à jouer ?</a></li></ul><ul><li><a href=#expliquer-lefficacit%c3%a9-des-algorithmes-avec-des-cartes>Expliquer l&rsquo;efficacité des algorithmes avec des cartes</a></li></ul><ul><li><a href=#expliquer-les-structures-de-donn%c3%a9es-avec-des-cartes>Expliquer les structures de données avec des cartes</a></li></ul><ul><li><a href=#plan-du-manuel>Plan du manuel</a></li></ul><ul><li><a href=#annexes>Annexes</a></li></ul></ul></nav></aside></header><article class=markdown><h1 id=introduction>Introduction
<a class=anchor href=#introduction>#</a></h1><blockquote><p>Dans ce manuel, nous proposons une approche pour enseigner la programmation
avec des cartes à jouer. Les étudiant·e·s seront invité·es à réaliser une
procédure informatique avec des cartes, avant de programmer cette procédure
en Java et, puis de valider leur code à l&rsquo;aide d&rsquo;un logiciel créé
spécifiquement pour accompagner ce manuel.</p><p>Nous utilisons ensuite cette approche pour expliquer les notions d&rsquo;efficacité
(complexité des algorithmes) et de structure de données (en particulier les
listes, les arbres et les mappages).</p></blockquote><h2 id=à-qui-sadresse-ce-manuelnbsp>À qui s&rsquo;adresse ce manuel ?
<a class=anchor href=#%c3%a0-qui-sadresse-ce-manuelnbsp>#</a></h2><p>L&rsquo;approche développée dans ce manuel cible des étudiant·e·s ayant déjà suivi un
cours d&rsquo;introduction à la programmation, mais qui pourraient éprouver certaines
difficultés à :</p><ul><li>Imaginer les étapes exactes d&rsquo;une procédure informatique.</li><li>Imaginer comment les données du programme sont organisées en mémoire.</li><li>Réfléchir à l’efficacité du programme.</li><li>Distinguer les notions d&rsquo;interface (ce que le programme doit faire) et d&rsquo;implantation (comment le programme le fait).</li></ul><p>Comme les exemples de code sont en Java, il est préférable d&rsquo;avoir une certaine familiarité avec ce langage (ou avec un langage similaire comme C#).</p><h2 id=pourquoi-utiliser-des-cartes-à-jouernbsp>Pourquoi utiliser des cartes à jouer ?
<a class=anchor href=#pourquoi-utiliser-des-cartes-%c3%a0-jouernbsp>#</a></h2><p>L&rsquo;idée est d&rsquo;utiliser un médium physique pour expliquer des notions de
programmation, afin de répondre à différents styles d&rsquo;apprentissage (visuel,
kinesthésique) et d&rsquo;encourager les étudiant·e·s à bien comprendre le déroulement
d&rsquo;une procédure informatique avant même de commencer à la programmer.</p><p>Les cartes à jouer sont avantageuses parce qu&rsquo;elles sont accessibles
et peu coûteuses. P. ex. il est facile de se procurer des
cartes surdimensionnées pour expliquer des notions informatiques
devant la classe de façon très visuelle.</p><center><table><tr><td><img class=small-figure src=/approche/trier/trier_par_numero03.jpg><br>&nbsp;</td><td style=text-align:right><img class=small-figure src=/approche/trier/trier_par_numero02.jpg><br>Crédit photo&nbsp;: Mikael Tardif</td></table></center><p>Un autre avantage est qu&rsquo;on peut vérifier la compréhension des étudiant·e·s dès
la période de théorie, sans même avoir besoin d&rsquo;ordinateurs. Dans l&rsquo;exemple
ci-dessous, on spécifie visuellement une opération à effectuer sur une liste de
cartes. Cette opération consiste à déplacer une carte (identifiée par un marqueur) au début de
liste, ce qui nécessite en retour de décaler certaines cartes vers la droite.</p><center><table><tr><th>&nbsp;</th><th>Énoncé visuel</th><th>Manipulations sur la table</th></tr><tr><th>Opération à réaliser</th><td><video autoplay loop mute controls style=width:300px>
<source src=decaler_objectif_animation.mp4 type=video/mp4><source src=decaler_objectif_animation.webm type=video/webm></video></td><td><video autoplay loop mute controls style=width:300px>
<source src=decaler_objectif.mp4 type=video/mp4><source src=decaler_objectif.webm type=video/webm></video></td></tr></table></center><p>On peut demander aux étudiant·e·s d&rsquo;effectuer cette opération avec des vraies cartes,
permettant ainsi à l&rsquo;enseignant·e de vérifier que l&rsquo;énoncé a bien été compris (c.-à-d. l&rsquo;interface, ou ce que le programme doit faire).</p><p>On peut ensuite présenter une procédure afin de réaliser l&rsquo;opération (c.-à-d. l&rsquo;implantation, ou comment le
programme doit le faire). Dans l&rsquo;exemple ci-dessous, on utilise une procédure qui parcourt la liste du début vers la fin (ce qui correspond au genre de boucle que les étudiant·e·s ont probablement déjà appris).
Encore une fois, les étudiant·e·s pourront réaliser la procédure sur la table, avec de vraies cartes, et
ainsi s&rsquo;assurer de comprendre ce qu&rsquo;il faut programmer avant même d&rsquo;écrire les premières lignes de code.</p><center><table><tr><th>&nbsp;</th><th>Énoncé visuel</th><th>Manipulations sur la table</th></tr><th>Procédure à suivre</th><td><video autoplay loop mute controls style=width:300px>
<source src=decaler_procedure_animation.mp4 type=video/mp4><source src=decaler_procedure_animation.webm type=video/webm></video></td><td><video autoplay loop mute controls style=width:300px>
<source src=decaler_procedure.mp4 type=video/mp4><source src=decaler_procedure.webm type=video/webm></video></td></tr></table></center><p>Finalement, à noter les animations ci-haut sont tirées de l&rsquo;outil de validation qui
accompagne ce manuel. Grâce à cet outil, les étudiant·e·s peuvent valider
leur programme, en particulier :</p><ul><li>Visualiser les étapes d&rsquo;exécution de leur code.</li><li>Vérifier que leur code arrive au bon résultat.</li></ul><h2 id=expliquer-lefficacité-des-algorithmes-avec-des-cartes>Expliquer l&rsquo;efficacité des algorithmes avec des cartes
<a class=anchor href=#expliquer-lefficacit%c3%a9-des-algorithmes-avec-des-cartes>#</a></h2><p>Une fois les étudiant·e·s habitué·es à réaliser des procédures avec les cartes à
jouer, on peut passer à expliquer la notion d&rsquo;efficacité (complexité des
algorithmes), c.-à-d. comment différentes procédures informatiques peuvent
accomplir la même opération (arriver au même résultat), tout en nécessitant un
nombre d&rsquo;étapes significativement différent.</p><p>On distingue ainsi entre les procédures naïves (souvent plus faciles à
comprendre, mais peu efficaces) et les procédures efficaces (souvent plus
difficiles à comprendre, mais plus rapides à réaliser). P. ex. pour une
liste de 10 cartes, ordonner les cartes avec une procédure naïve de tri nécessitera une centaine étapes, alors
qu&rsquo;une procédure efficace de tri arrivera au même résultat en une trentaine d&rsquo;étapes.</p><p>En effectuant diverses procédures sur la table, avec des vraies cartes à jouer, les étudiant·e·s
gagnent une compréhension très intuitive de la notion d&rsquo;efficacité informatique:
les procédures naïves se révèlent rapidement comme longues et ennuyantes à réaliser!</p><h2 id=expliquer-les-structures-de-données-avec-des-cartes>Expliquer les structures de données avec des cartes
<a class=anchor href=#expliquer-les-structures-de-donn%c3%a9es-avec-des-cartes>#</a></h2><p>Finalement, on peut aussi se servir de cartes à jouer afin de visualiser
l&rsquo;organisation des données dans un programme
informatique, ce qui est particulièrement intéressant utile pour expliquer
comment une structure de données, comme une liste,
peut être implantée de différentes façons dans un langage de programmation.</p><p>En s&rsquo;appuyant sur la notion d&rsquo;efficacité, on peut aussi expliquer les
avantages et inconvénients de ces différentes implantations.
P. ex. une liste implantée par
références (liste chaînée) sera moins efficace qu&rsquo;une liste implantée par
tableau au moment de visiter une valeur mémorisée au milieu de la liste.
Par contre, la liste par référence utilisera moins d&rsquo;espace en mémoire.</p><p>On peut visualiser ce dernier point assez concrètement avec des cartes à jouer,
surtout si on utilise des cartes blanches (ou le verso de cartes) pour
visualiser l&rsquo;espace mémoire vide (c.-à-d. l&rsquo;espace occupé par le programme, mais
dans lequel le programme n&rsquo;a pas encore mémorisé de valeur). Une procédure
utilisant beaucoup d&rsquo;espace mémoire va tout simplement nécessiter plus d&rsquo;espace
sur la table !</p><h2 id=plan-du-manuel>Plan du manuel
<a class=anchor href=#plan-du-manuel>#</a></h2><table><tr><th><a href=/approche>Chapitre 1</a></th><td><p>Nous présentons l&rsquo;approche de façon plus détaillée, y compris en survolant
les fonctionnalités de l&rsquo;outil de validation qui accompagne ce manuel.
Nous discutons des langages et notations que nous utilisons (Java, JSON, diagrammes de classe et graphe d&rsquo;objets).
Nous donnons des exemples du type de visualisation avec des cartes à jouer que notre approche supporte.</p></td></tr><tr><th><a href=/modelisation>Chapitre 2</a></th><td>Nous donnons des exemples de modélisation de données
qui cadrent bien avec l'approche que nous développons.
En particulier, nous considérons les notions d'objet, de tableau d'objets
et de graphe d'objets.
À travers ce chapitre, nous discutons aussi des limitations
de la visualisation avec des cartes à jouer.</td></tr><tr><th><span class=disabled>Chapitre 3</span></th><td>Nous présentons la notion d'efficacité de façon intuitive, sans entrer
dans les détails mathématiques (ce que nous réservons pour l'Annexe 1).
Nous distinguons les notions de performance (une mesure de temps d'exécution) et d'efficacité (une mesure
du nombre d'étapes qu'une procédure nécessite).
Nous différencions aussi l'efficacité en termes de temps (nombre d'étapes) et d'espace mémoire
et donnons quelques exemples du compromis bien connu entre temps et mémoire (on peut souvent réduire le
nombre d'étapes à exécuter si on accepte d'utiliser plus d'espace mémoire).</td></tr><tr><th><span class=disabled>Chapitre 4</span></th><td>Nous présentons notre première structure de données&nbsp;: la liste.
Nous présentons l'interface d'une liste (c.-à-d. quelles opérations une liste doit accomplir), ainsi
que quatre implantations différentes&nbsp;: liste naïve, liste par tableau, liste chaînée simple et liste chaînée double.
Présenter d'abord une implantation naïve nous permet à la fois de bien expliquer l'interface de la liste, mais
aussi d'obtenir un point de comparaison utile pour réfléchir à l'efficacité des différents types de liste.</td></tr><tr><th><span class=disabled>Chapitre 5</span></th><td>Nous présentons la notion d'arbre, une structure de données omniprésente en informatique.
Nous implanterons un arbre générique, ainsi qu'un arbre binaire de recherche.</td></tr><tr><th><span class=disabled>Chapitre 6</span></th><td>Nous présentons notre deuxième structure de données&nbsp;: le mappage.
Nous présentons l'interface d'un mappage,
que trois implantations différentes&nbsp;: mappage naïf, mappage par hachage et mappage par arbre.
Encore une fois, présenter d'abord une implantation naïve permet de bien expliquer l'interface et
d'obtenir un point de comparaison pour réfléchir à l'efficacité des différents types de mappage.</td></tr><tr><th><span class=disabled>Conclusion</span></th><td>En guise de conclusion, nous donnons nos impressions sur l'utilisation de notre approche en classe et discutons
d'améliorations et extensions possibles à l'approche.</td></tr><tr><th><a href=/bibliographie>Bibliographie</a></th><td>Références bibliographiques.</td></tr></table><h2 id=annexes>Annexes
<a class=anchor href=#annexes>#</a></h2><table><tr><th style=white-space:nowrap><a href=/annexe_grand_o>Annexe 1</a></th><td>La notation grand O est présentée de façon plus mathématique.</td></tr><tr><th style=white-space:nowrap><a href=/annexe_acceder_exemples>Annexe 2</a></th><td>Nous expliquons comment accéder aux exemples utilisés dans ce manuel.</td></tr><tr><th style=white-space:nowrap><a href=/annexe_programmer_exemple>Annexe 3</a></th><td>Nous expliquons comment ajouter un nouvel exemple à l'outil de validation.</td></tr><tr><th style=white-space:nowrap><a href=/annexe_modifier_manuel>Annexe 4</a></th><td>Nous expliquons comment adapter ce manuel, ou encore comment suggérer une modification à la version actuelle.</td></tr><tr><th style=white-space:nowrap><a href=/annexe_ateliers>Annexe 5</a></th><td>Nous présentons quatre exemples d'atelier qui utilisent l'approche développée dans ce manuel.</td></tr><tr><th style=white-space:nowrap><a href=/annexe_bilans>Annexe 6</a></th><td>Cet annexe archive les bilans rédigés lors du développement de ce manuel (avril 2022 à février 2023).</td></tr></table></article><br><br><div class=footer-next-page><a class=link-next-page href=https://cartesjava.github.io/approche/>↪&nbsp;Chapitre 1: &nbsp;présentation de l'approche</a></div><label for=menu-control class="hidden book-menu-overlay"></label></div><footer class=book-footer><div class="flex flex-wrap justify-between"><div style=padding-top:1em><div><a href=https://fabriquerel.org/><img style=width:16em;height:100% alt=FabriqueREL src=/F-REL_logo-coul-horiz.png></a></div></div><div style=padding-top:2em;margin-bottom:2em><a href=https://creativecommons.org/licenses/by-sa/4.0/deed.fr><img style=width:9rem;height:auto alt="Creative Commons License" src=/by-sa.png></a><div style=padding-top:1em><a href=https://github.com/cartesjava/cartesjava.github.io/edit/main//content/intro/_index.md target=_blank rel=noopener><span>Modifier cette page</span>
<img src=/svg/edit.svg class=book-icon alt=Edit></a></div></div><div style=padding-top:2em><div style=position:relative;left:1.25em><a href=https://www.cmontmorency.qc.ca/><img style=width:16em;height:100% alt="Collège Montmorency" src=/LogomoHC.png></a></div></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><ul><li><a href=#%c3%a0-qui-sadresse-ce-manuelnbsp>À qui s&rsquo;adresse ce manuel ?</a></li></ul><ul><li><a href=#pourquoi-utiliser-des-cartes-%c3%a0-jouernbsp>Pourquoi utiliser des cartes à jouer ?</a></li></ul><ul><li><a href=#expliquer-lefficacit%c3%a9-des-algorithmes-avec-des-cartes>Expliquer l&rsquo;efficacité des algorithmes avec des cartes</a></li></ul><ul><li><a href=#expliquer-les-structures-de-donn%c3%a9es-avec-des-cartes>Expliquer les structures de données avec des cartes</a></li></ul><ul><li><a href=#plan-du-manuel>Plan du manuel</a></li></ul><ul><li><a href=#annexes>Annexes</a></li></ul></ul></nav></div></aside></main></body></html>