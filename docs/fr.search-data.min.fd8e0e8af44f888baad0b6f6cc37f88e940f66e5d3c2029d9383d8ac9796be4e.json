[{"id":0,"href":"/efficacite/temps02/ChercheurNaif/","title":"Chercheur Naif","section":"Efficacité en temps (2)","content":"int trouverIndicePourValeur(tableau, valeur):\n POUR TOUS les éléments el du tableau:  SI el est égal à la valeur cherchée:  mémoriser l\u0026rsquo;indice i de l\u0026rsquo;élément el     retourner le dernier indice i mémorisé  "},{"id":1,"href":"/efficacite/temps02/TrieurNaif/","title":"Trieur Naif","section":"Efficacité en temps (2)","content":"Tableau\u0026lt;C\u0026gt; trier(Tableau\u0026lt;C\u0026gt; entree):\n CRÉER un tableau resultat vide TANT QUE le tableau entree n\u0026rsquo;est pas vide  appeler valeurMinimale et mémoriser la valeur de retour retirer cette valeur du tableau entree ajouter cette valeur à la fin du tableau resultat   retourner le tableau resultat  "},{"id":2,"href":"/efficacite/temps02/TrieurNaif_valeurMinimale/","title":"Trieur Naif Valeur Minimale","section":"Efficacité en temps (2)","content":"Valeur obtenirValeurMinimale(tableau):\n considérer que le premier élément du tableau est la valeur minimale POUR TOUS les éléments el du tableau:  SI el est plus petit que la valeur minimale courante:  mémoriser el comme la nouvelle valeur minimale courante     retourner la valeur minimale  "},{"id":3,"href":"/efficacite/temps02/TriFusion/","title":"Tri Fusion","section":"Efficacité en temps (2)","content":"Tableau trier(Tableau entree):\n CRÉER un tableau resultat vide SI entree contient un seul élément ou moins:  copier entree dans resultat   SINON:  diviser le tableau entree en deux sous-tableaux égaux appeler trier() pour trier chaque sous-tableau appeler fusionner() pour fusionner les deux sous-tableaux copier le tableau fusionné dans resultat   retourner le tableau resultat  "},{"id":4,"href":"/efficacite/temps02/TriFusion_fusionner/","title":"Tri Fusion Fusionner","section":"Efficacité en temps (2)","content":"Tableau fusionner(Tableau gauche, Tableau droite):\n CRÉER un tableau resultat vide TANT QUE gauche n\u0026rsquo;est pas vide ET QUE droite n\u0026rsquo;est pas vide:  SI le premier élément de gauche est plus petit que le premier élément de droite:  obtenir le premier élément de gauche retirer cet élément à gauche ajouter cet élément à la fin de resultat   SINON  obtenir le premier élément de droite retirer cet élément à droite ajouter cet élément à la fin de resultat     SI gauche n\u0026rsquo;est pas vide:  retirer chaque élément de gauche et les ajouter dans l\u0026rsquo;ordre à la fin de resultat   SINON:  retirer chaque élément de droite et les ajouter dans l\u0026rsquo;ordre à la fin de resultat   retourner le tableau resultat  "},{"id":5,"href":"/preface/bilan_juin_2022/","title":"Bilan juin 2022","section":"Préface","content":"Bilan juin 2022 Projets étudiants   De gauche à droite:\n Zein-El-Abdin Hazimeh Mathieu Bergeron Marlond Augustin Adrien Joséphine-Olivier       Crédit photo: Marlond Augustin Les participants ont signé un formulaire de consentement concernant la reproduction des trois photos ci-haut.  Fonctionalités implantées Interface de base   NOTES:\n Des améliorations à l\u0026rsquo;interface sont à venir (projet de Zein Hazimeh)  Validation interactive du code Comparaison du code étudiant (erreur à l\u0026rsquo;étape 22):\n  Avec la solution (étape 22):\n  Animation d\u0026rsquo;un tri naïf   Réalisation à l\u0026rsquo;écran d\u0026rsquo;un tri naïf   Animation de l\u0026rsquo;opération de retrait dans une liste tableau   Choix entre différents exemples   Prochaine étape: intégration des outils au cours 3C6   Évaluations formatives avec les cartes\n entrevue de 5min avec l\u0026rsquo;enseignant l\u0026rsquo;étudiant.e doit démontrer sa compréhension de la procédure vue en théorie    Ateliers à réaliser avec l\u0026rsquo;outil de validation codelescartes.ca\n introduction liste par tableau (projet de Marlond Augustin) tri fusion (projet d\u0026rsquo;Adrien Joséphine-Olivier) tri naïf liste chaînée simple et double mappage par arbre binaire    Voir la page du cours 3C6\n"},{"id":6,"href":"/preface/bilan_octobre_2022/","title":"Bilan octobre 2022","section":"Préface","content":"Bilan octobre 2022 Avancement actuel Brouillons sur codelescartes.ca\n Présentation de l\u0026rsquo;approche Comment modifier ce manuel  Matériel de mon cours 3C6 développé pour ce projet et qu\u0026rsquo;il reste à inclure dans le manuel codelescartes.ca\n Procédure pour déplacer/décaler des cartes Modéliser des cartes  graphe d\u0026rsquo;objets   Récursivité  modélisation de la séquence de Fibonacci    Matériel qui existait déjà pour mon cours 3C6 et qu\u0026rsquo;il reste à inclure dans le manuel codelescartes.ca\n Structures de données en Java Structures de données en JSON  Ressources trouvées par Valérie Jacques Les ressources ci-bas pourront servir d\u0026rsquo;inspiration pour le manuel:\nAlgorithms and Data Structures With Application to Graphics and Geometry(2011) de Jurg Nievergelt et Klaus Hinrichs ;\u0026nbsp;Data Structures : {fundamental tools}(revisé en 2020) de Alfred V. Aho, Jeffrey D. Ullman et al. [Wikibooks] ;\u0026nbsp;Introduction to Programming Using Java (8 éd., 2022) de David J. Eck ;\u0026nbsp;Java, Java, Java : Object-Oriented Problem Solving (2017) de Ralph Morelli et Ralph Walde ;\u0026nbsp;Programming Fundamentals : A Modular Structured Approach (2e éd., 2018) de Kenneth Leroy Busbee et Dave Braunschweig ;\u0026nbsp;Think Java : How to Think Like a Computer Scientist (2e éd., 2020) de Chris Mayfield et Allen Downey.\u0026nbsp; Pour l\u0026rsquo;instant, il n\u0026rsquo;est pas prévu de traduire des sections des ressources ci-haut dans le but des intégrer au présent manuel.\nPour finaliser le projet   L\u0026rsquo;objectif pour février 2023 est de rédiger 25% du manuel initialement prévu, soit environs 50 pages\n  L\u0026rsquo;objectif demeure réaliste\n le matériel créé pour ce projet compte déjà envrions 20 pages le matériel que j\u0026rsquo;ai déjà compte pour un autre 20 pages    À noter que cette portion du manuel risque d\u0026rsquo;être partiellement réécrite puisque l\u0026rsquo;approche a encore besoin d\u0026rsquo;être peaufinée\n  Impressions et réflexions Ce qui fonctionne bien   C\u0026rsquo;est très aggréable d\u0026rsquo;utiliser les cartes surdimensionnées pour expliquer une procédure au tableau blanc:\ncrédit photo: Mikael Tardif\n  C\u0026rsquo;est aussi très aggréable de faire des séances de théorie 100% au tableau blanc, sans utiliser le projecteur\n  Les étudiant.es semblent apprécier l\u0026rsquo;utilisation de cartes à jouer et adhérent bien à l\u0026rsquo;idée de faire des entrevues formatives\n (durant l\u0026rsquo;entrevue formative, l\u0026rsquo;étudiant.e démontre sa compréhension de la théorie avec des cartes ou en dessinant un schéma sur papier)    Les étudiant.es semblent beaucoup apprécier l\u0026rsquo;outil de validation, en particulier le fait que l\u0026rsquo;outil génère des visualisation à partir de leur code. P.ex.\ncartes = new MaCarte[] {new MaCarte(1, Sorte.CARREAU), null, new MaCarte(1, Sorte.COEUR)}; memoireA = null; memoireB = new MaCarte(1, Sorte.TREFLE); i = 1; aDeplacer = 2;    Ce qui reste à peaufiner   Tout! L\u0026rsquo;approche a besoin de «vivre un peu». P.ex.\n plusieurs étudiant.es ont pris du temps à réaliser que l\u0026rsquo;outil de validation générait des visualisations à partir de leur code. Il faudra trouver des façons de présenter cet aspect plus directement (d\u0026rsquo;autant plus que c\u0026rsquo;est un aspect très apprécié une fois découvert!). les étudiant.es ont trouvé facile de trier des cartes, mais plus difficile de traduire en code la procédure. Je pense que je devrai fournir plus d\u0026rsquo;exemples plus rapidement afin de pratiquer cette «traduction».    Malheureusement, pour l\u0026rsquo;instant, créer un nouvel exemple de visualisation est difficle et long. Je dois écrire beaucoup de code pour créer les visualisations et ces dernières doivent quand même être capturées à la main avec un outil de capture d\u0026rsquo;écran. Certains graphes d\u0026rsquo;objets doivent aussi être retravailler à la main, p.ex. ci-bas pour y inclure la variable nouvelleTete\n  Trois «intuitions de programmeur» à mieux enseigner   Construire et imaginer un graphe d\u0026rsquo;objets\n  Utiliser une variable de type «curseur» pour pointer sur différents objets d\u0026rsquo;un graphe d\u0026rsquo;objets durant l\u0026rsquo;exécution du programme\n  Utiliser des appels récursifs pour construire un graphe d\u0026rsquo;objet\n  "},{"id":7,"href":"/modelisation/java/graphe/","title":"Dessiner un graphe d'objets","section":"Modéliser en Java","content":"Dessiner un graphe d\u0026rsquo;objets   Un modèle Java contient des références\n Un Personnage apparaît dans plusieurs Film Un Film contient plusieurs Personnage    Très souvent, ces références forment des boucles\n Le Personnage James Bond apparaît dans deux films: Dr. No et Bon Baisers de Russie Le Film Dr. No contient deux personnages: James Bond et Dr. no    On parle alors de graphe d\u0026rsquo;objets (plutôt que de tableau d\u0026rsquo;objets)\n  Graphe d\u0026rsquo;objets en JSON   JSON n\u0026rsquo;a pas de notion de référence\n  Dans ce cours, on ajoute un objet spécial {\u0026quot;_R\u0026quot;:\u0026quot;/chemin/vers/objet/cible\u0026quot;} pour représenter certaines références\n (sans l\u0026rsquo;objet spécial, on ne peut pas représenter les boucles)    Par exemple, le graphe ci-haut est représenté comme suit en JSON\n  { \u0026#34;_C\u0026#34;: \u0026#34;DrNo\u0026#34;, \u0026#34;titre\u0026#34;: \u0026#34;Dr. No\u0026#34;, \u0026#34;personnages\u0026#34;: [ { \u0026#34;_C\u0026#34;: \u0026#34;Personnage\u0026#34;, \u0026#34;films\u0026#34;: [ { \u0026#34;_R\u0026#34;: \u0026#34;/\u0026#34; }, { \u0026#34;_C\u0026#34;: \u0026#34;Film\u0026#34;, \u0026#34;titre\u0026#34;: \u0026#34;Bons Baisers de Russie\u0026#34;, \u0026#34;personnages\u0026#34;: [ { \u0026#34;_R\u0026#34;: \u0026#34;/personnages/0\u0026#34; }, { \u0026#34;_C\u0026#34;: \u0026#34;Personnage\u0026#34;, \u0026#34;films\u0026#34;: [ { \u0026#34;_R\u0026#34;: \u0026#34;/personnages/0/films/1\u0026#34; } ], \u0026#34;nom\u0026#34;: \u0026#34;Rosa Klebb\u0026#34; } ] } ], \u0026#34;nom\u0026#34;: \u0026#34;James Bond\u0026#34; }, { \u0026#34;_C\u0026#34;: \u0026#34;Personnage\u0026#34;, \u0026#34;films\u0026#34;: [ { \u0026#34;_R\u0026#34;: \u0026#34;/\u0026#34; } ], \u0026#34;nom\u0026#34;: \u0026#34;Docteur No\u0026#34; } ] }  NOTE:\n on ne va pas vous demander d\u0026rsquo;écrire du JSON avec l\u0026rsquo;objet spécial {\u0026quot;_R\u0026quot;:\u0026quot;/chemin/cible\u0026quot;} il vous faut uniquement comprendre que ça existe et comprendre la notion de graphe d\u0026rsquo;objets en POO   "},{"id":8,"href":"/modelisation/java/dessiner_tableau/","title":"Dessiner un tableau d'objets","section":"Modéliser en Java","content":"Dessiner un tableau d\u0026rsquo;objets Visualiser les objets Exemple 1 Exemple 2 Comprendre l\u0026rsquo;effet d\u0026rsquo;instructions typiques Accéder à une valeur Example 1   Objets au départ Instructions Résultat      memoireA.getNumero(); memoireA.getSorte();   5 \u0026#34;TREFLE\u0026#34;    Example 2   Objets au départ Instructions Résultat      cartes[2].getNumero(); cartes[2].getSorte();   3 \u0026#34;CARREAU\u0026#34;    Example 3   Objets au départ Instructions Résultat      cartes[2].getNumero(); memoireB.getNumero();   java.lang.NullPointerException java.lang.NullPointerException    Déplacer un objet (déplacer une carte) Exemple 1   Objets au départ Instruction Résultat      memoireA = cartes[0]; cartes[0] = null;      Exemple 2   Objets au départ Instruction Résultat      cartes[2] = cartes[0]; cartes[0] = null;      Copier la référence à un objet Exemple 1   Objets au départ Instruction Résultat      memoireA = cartes[0];      Exemple 2   Objets au départ Instruction Résultat      cartes[2] = cartes[0];      Créer un nouvel objet (créer une nouvelle carte) Exemple 1   Objets au départ Instruction Résultat      memoireA = new Carte(2, \u0026#34;TREFLE\u0026#34;);      Exemple 2   Objets au départ Instruction Résultat      memoireB = new Carte(5, \u0026#34;TREFLE\u0026#34;);      "},{"id":9,"href":"/modelisation/recursivite/fibonacci/","title":"Fibonacci","section":"Récursivité","content":"Fibonacci Définition   Voici le début de la suite de Fibonacci\n0 1 1 2 3 5 8 13 21 34 55 89 144 ...   La définition mathématique est récursive\n \\( F_0 = 0\\\\~\\\\ F_1 = 1\\\\~\\\\ F_n = F_{n-1} \u0026#43; F_{n-2}\\\\~\\\\ \\)    Autrement dit:\n  0 et 1 sont deux cas spéciaux\n  sinon le prochain nombre de la suite est toujours l\u0026rsquo;addition deux nombres précédents\n    Nombre d\u0026rsquo;or   La suite de Fibonacci est utilisée pour calculer le nombre d\u0026rsquo;or, soit environs 1.618\n (le nombre d\u0026rsquo;or est reconnu, entre autres choses, comme une proportion hauteur/largeur agréable à l\u0026rsquo;oeil)    Comme pour π, on peut le calculer le nombre d\u0026rsquo;or avec autant que précision que désiré\n (c-à-d avec autant de chiffres après le point que désiré)    Pour calculer un approximation du nombre d\u0026rsquo;or on fait tout simplement:\n\\( \\text{nombre d\u0026#39;or} \\approx \\dfrac{F_{n}}{F_{n-1}} \\text{~~~pour~~~} n\\geq 2 \\)    Plus on prend un n élevé, plus la précision est bonne\n  Autrement dit, le nombre d\u0026rsquo;or est à peu près égal à:\n  un nombre de la suite de Fibonacci, divisé par le nombre qui le précède\n  (plus on prend un nombre loin dans la suite, plus l\u0026rsquo;approximation est bonne)\n    Modéliser la suite de Fibonnaci  Pour modéliser la suite en Java, on va créer une structure de données récursive      Pour n = 0, on a le graphe d\u0026rsquo;objets suivant\n  Pour n = 1, on a le graphe d\u0026rsquo;objets suivant\n  Pour n = 2, on a le graphe d\u0026rsquo;objets suivant\n NOTE: la suite se lit de droite à gauche    Pour n = 3, on a le graphe d\u0026rsquo;objets suivant\n  Et ainsi de suite\u0026hellip;\n   Il existe une modélisation plus simple. Chut, ne le dis pas! C\u0026rsquo;est la question bonus de l\u0026rsquo;atelier 2.3. Pour calculer la réponse et le nombre d\u0026rsquo;or   Calculer la réponse pour n \u0026gt;= 2 est simple\nreponse = moinsUn.getReponse() + moinsDeux.getReponse();   Même chose pour le nombre d\u0026rsquo;or\nnombreOr = Double.valueOf(reponse) / Double.valueOf(moinsUn.getReponse());   Le défi est qu\u0026rsquo;il faut d\u0026rsquo;abord construire le graphe d\u0026rsquo;objet\n  Construire le graphe d\u0026rsquo;objets récursivement   Avec des appels récursifs, on va construire d\u0026rsquo;abord, puis calculer\n    on crée d\u0026rsquo;abord l\u0026rsquo;objet n, puis n-1, et ainsi de suite jusqu\u0026rsquo;à l\u0026rsquo;objet 0    Pour le cas n \u0026gt;= 2, voici comment procéder\n  créer un nouvel objet MonFibonacci et le mémoriser dans moinsUn\n  enregistrer que le n de ce moinsUn est n-1 (le n courant moins 1)\n  créer le reste du graphe récursivement en appelant moinsUn.construireGrapheRecursivement()\n  enregister que le moinsDeux courant est moinsUn.getMoinsUn() (le moinsUn du moinsUn courant)\n  calculer la réponse courante à partir des réponses de moinsUn et moinsDeux\n    L\u0026rsquo;appel récursif est plus proche de la définition mathématique\n (pour calculer la réponse en n, il faut d\u0026rsquo;abord calculer la réponse en n-1)    L\u0026rsquo;inconvénient est qu\u0026rsquo;on peut déborder la pile d\u0026rsquo;appel\nException in thread \u0026quot;main\u0026quot; java.lang.StackOverflowError at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) ...  RAPPEL: le code n\u0026rsquo;est pas bogué, mais limité par la mémoire attribuée à la pile d\u0026rsquo;appel    Construire le graphe d\u0026rsquo;objets dynamiquement   En programmation dynamique, on calcule en même temps qu\u0026rsquo;on construit\n    on crée d\u0026rsquo;abord l\u0026rsquo;objet 0, puis 1, et ainsi de suite jusqu\u0026rsquo;à l\u0026rsquo;objet n    L\u0026rsquo;idée est qu\u0026rsquo;on fait une boucle pour créer le graphe d\u0026rsquo;objets\n  on crée une nouvelleTete\n  le moinsUn de la nouvelleTete est l\u0026rsquo;ancienne tete\n  le moinsDeux de la nouvelleTete est le moinsUn de l\u0026rsquo;ancienne tete\n  c-à-d on insère la nouvelleTete à gauche, et on «pousse» les objets existants vers la droite\n    Pour le cas n \u0026gt;= 2, voici comment procéder\n  pour chaque i allant de 2 à n (inclusivement)\n  créer un nouvel objet MonFibonacci pour représenter la nouvelleTete\n  enregistrer que le n de la nouvelleTete est i\n  enregistrer que le moinsUn de la nouvelleTete est la tete courante\n  enregistrer que le moinsDeux de la nouvelleTete est le moinsUn de la tete courante\n  enregistrer que tete pointe maintenant vers la nouvelleTete\n  calculer la réponse pour tete\n      Le calcul dynamique est moins intuitif (et moins proche de la définition mathématique), mais\n on a éliminé l\u0026rsquo;appel récursif, alors on ne peut plus déborder la pile d\u0026rsquo;appel    "},{"id":10,"href":"/modelisation/json/format_json/","title":"Format JSON","section":"Modéliser en JSON","content":"Format JSON   Le format JSON est très populaire pour représenter des données\n  JSON veut dire Javascript Object Notation\n  C\u0026rsquo;est le format prévilégié pour les applications Web\n  Les bases de données NoSQL utilisent souvent un format similaire à JSON\n  Voici les valeurs en JSON:\n la valeur nulle: null un booléen: true ou false un nombre comme: 1, 4.5, -10.1 une chaîne comme: \u0026quot;asdf\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;Bonjour!\u0026quot;    Voici les structures en JSON:\n une liste comme:  [1, 3, -1] [] [\u0026quot;asfd\u0026quot;, \u0026quot;Bonjour!\u0026quot;, \u0026quot;\u0026quot;]   une objet comme:  {\u0026quot;cle01\u0026quot;:true} {} {\u0026quot;cle01\u0026quot;:true, \u0026quot;cle02\u0026quot;:-12}      Les listes en JSON  Une liste est un tableau qui peut grandir et rapetisser  public interface ListeJava\u0026lt;V extends Object\u0026gt; { boolean siVide(); int longueur(); V obtenirValeur(int indice); void modifierValeur(int indice, V nouvelleValeur); void ajouter(V nouvelleValeur); // la liste grandit  void retirer(int indice); // la liste rapetisse  void retirer(V valeur); }  Une des particularité des la liste JSON est de mélanger les types de valeurs:  [1,true,\u0026quot;Bonjour!\u0026quot;] [null, \u0026quot;\u0026quot;, 1, false]    Les objets JSON   Un objet JSON permet d\u0026rsquo;accéder à des valeurs avec des clés\n une clé est toujours une chaîne la valeur peut être n\u0026rsquo;importe quelle valeur JSON    L\u0026rsquo;objet JSON est un exemple de Dictionnaire:\n  public interface Dictionnaire\u0026lt;V extends Object\u0026gt; { void entreposerValeur(String cle, V valeur); V recuprerValeur(String cle); String trouverCle(V valeur); }  Quand on entrepose une valeur, le dictionnaire:  grandit si la clé n\u0026rsquo;existait pas modifie la valeur si la clé existait    Dictionnaire\u0026lt;Integer\u0026gt; dico = new MonDictionnaire\u0026lt;\u0026gt;(); // {} dico.entreposerValeur(\u0026#34;cle01\u0026#34;, 12); // {\u0026#34;cle01\u0026#34;:12} dico.entreposerValeur(\u0026#34;cle01\u0026#34;, 42); // {\u0026#34;cle01\u0026#34;:42} dico.entreposerValeur(\u0026#34;cle02\u0026#34;, 14); // {\u0026#34;cle01\u0026#34;:42, \u0026#34;cle02\u0026#34;:14}  JSON est un format récursif   La présentation de JSON à date est incomplète\n  En fait, JSON est un format récursif:\n on peut avoir [1,2,[2,4]] (une liste à l\u0026rsquo;intérieur d\u0026rsquo;une liste) on peut avoir [1,2,[2,[5,423]]] on peut avoir [1,2,[2,[[44,2],423]]] etc.    Les structures récursives sont très populaires en informatique\n  Avant de continuer avec JSON, on va regarder la notion d\u0026rsquo;arbre\n  L\u0026rsquo;arbre est une structure récursive assez simple\n  On peut penser à une liste récursive comme à un arbre:\n p.ex: [1,2,[2,[[44,2],423]]]     une liste contenant  1 2 une liste contenant  2 une liste contenant  une liste contenant  44 2   423          On voit qu\u0026rsquo;une liste peut être insérée à la place d\u0026rsquo;une valeur\n  C\u0026rsquo;est la même chose pour les objets JSON\n  Partout où on s\u0026rsquo;attend à avoir une valeur, on peut avoir une liste ou un objet\n  Par exemple, voici des données JSON valides:\n {\u0026quot;cle01\u0026quot;:[1,4,true,null,[1,\u0026quot;asdf\u0026quot;],{\u0026quot;test\u0026quot;:false}]} [4.0,-2,{\u0026quot;un\u0026quot;:1,\u0026quot;deux\u0026quot;:2,\u0026quot;trois\u0026quot;:{\u0026quot;nom\u0026quot;:\u0026quot;Trois\u0026quot;}}] \u0026hellip;    "},{"id":11,"href":"/listes/tableau/","title":"Liste par tableau","section":"Comprendre les listes","content":"Liste par tableau  Une liste est un tableau qui peut grandir et rapetisser  ListeJava\u0026lt;Character\u0026gt; liste = new ListeJava\u0026lt;\u0026gt;(Character.class); liste; // [] liste.add(\u0026#39;a\u0026#39;) // [a] liste.add(\u0026#39;b\u0026#39;) // [a,b] liste.add(\u0026#39;c\u0026#39;) // [a,b,c] liste.set(1,\u0026#39;d\u0026#39;) // [a,d,c] liste.remove(\u0026#39;a\u0026#39;) // [b,c]    Comment implanter une liste de façon efficace?\n  Ça dépend. Efficace pour quelle opération?:\n la modification d\u0026rsquo;éléments existants? (module 5.1) l\u0026rsquo;ajout et le retrait de nouveaux éléments? (module 5.2)    O(1): temps constant   Quand on a parlé d\u0026rsquo;efficacité, on a définit:\n Efficace:  O(log(n)): temps logarithmique O(n): temps linéaire   Pas efficace:  O(n2): temps quadratique O(2n): temps exponentiel      Il faut ajouter:\n Efficace:  O(1): temps constant  le nombre d\u0026rsquo;instructions ne dépend pas de la taille des données        Accéder à une valeur dans un tableau se fait en temps contant:\n  char[] tableau = new char[TAILLE]; char element(int position){ return tableau[position]; // 1 instruction  // même si TAILLE est grand   Même chose pour modifier une valeur dans un tableau:  char[] tableau = new char[TAILLE]; void modifier(int position, char element){ tableau[position] = element; // 1 instruction  // même si TAILLE est grand } Liste par tableau naïve  Le plus simple est de mémoriser les éléments de la liste dans un tableau  public class ListeJavaNaive\u0026lt;E extends Object\u0026gt; extends ListeJava\u0026lt;E\u0026gt; { private E[] elements;  La modification d\u0026rsquo;un élément existant se fera en temps constant  @Override public void set(int i, E e) { elements[i] = e; }  Pour ajouter un nouvel élément, c\u0026rsquo;est plus compliqué:  @Override public void add(E e) { E[] nouveauxElements = nouveauTableau(elements.length + 1); for(int i = 0; i \u0026lt; elements.length; i++){ nouveauxElements[i] = elements[i]; } nouveauxElements[nouveauxElements.length - 1] = e; elements = nouveauxElements; }   Pour ajouter un élément, il faut:\n créer un nouveau tableau plus grand d\u0026rsquo;un emplacement copier les éléments existants dans le nouveau tableau mémoriser le nouvel élement dans le nouvel emplacement    L\u0026rsquo;opération se fait en temps linéaire O(n)\n  Le problème est que add est typiquement utilisé dans une boucle\n  P.ex. pour mélanger une liste:\n  ListeJava\u0026lt;Character\u0026gt; melanger(ListeJava\u0026lt;Character\u0026gt; entree){ ListeJava\u0026lt;Character\u0026gt; resultat; resultat = nouvelleListe(); while(!entree.isEmpty()){ int positionAuHasard = alea.nextInt(entree.size()); Character elementAuHasard = entree.get(positionAuHasard); resultat.add(elementAuHasard); // cache une boucle?  entree.remove(positionAuHasard); // cache une boucle?  } return resultat; }   On a une boucle qui visite les éléments de entree\n si chaque add requiert une autre boucle sur les éléments on va avoir une boucle dans une boucle et donc O(n2)      Liste par tableau plus efficace   Si on veut être plus efficace, il faut éviter de toujours recopier les éléments\n  Une façon de faire est d\u0026rsquo;utiliser un tableau plus grand\n  public class ListeJavaArray\u0026lt;E extends Object\u0026gt; extends ListeJava\u0026lt;E\u0026gt; { private final int TAILLE_INITIALE = 1; // Pour tester aggrandir  private E[] grosTableau; private int indiceDernierElement = -1;  Quand on ajoute un élément, on peut simplement mémoriser que la liste grandit  @Override public void add(E e) { indiceDernierElement++; grosTableau[indiceDernierElement] = e;  Évidemment, il faudra parfois faire grandir le tableau aussi:  indiceDernierElement++; grosTableau[indiceDernierElement] = e;   Néanmoins, add est beaucoup plus efficace:\n    Ainsi que retirer à la fin:\n    C\u0026rsquo;est un exemple de compromis temps/espace mémoire\n en utilisant plus d\u0026rsquo;espace mémoire, on améliore le temps d\u0026rsquo;exécution    Par contre, retirer au début est presqu\u0026rsquo;identique:\n    Exemples Ajouts à partir d\u0026rsquo;une liste vide    liste   [null,null,null,...,null] indiceDernierElement == -1     liste.add('a')   [a,null,null,...,null] indiceDernierElement == 0     liste.add('b')   [a,b,null,...,null] indiceDernierElement == 1    Un retrait au milieu    liste   [a,b,c,d,e,null,...,null] indiceDernierElement == 4     liste.remove('c')   [a,b,d,d,e,null,...,null] [a,b,d,e,e,null,...,null] indiceDernierElement == 3    Implanter un mélangeur effiace  Re-considérer notre mélangeur:  ListeJava\u0026lt;Character\u0026gt; melanger(ListeJava\u0026lt;Character\u0026gt; entree){ ListeJava\u0026lt;Character\u0026gt; resultat; resultat = nouvelleListe(); while(!entree.isEmpty()){ int positionAuHasard = alea.nextInt(entree.size()); Character elementAuHasard = entree.get(positionAuHasard); resultat.add(elementAuHasard); // efficace  entree.remove(positionAuHasard); // à éviter!  } return resultat; }   L\u0026rsquo;efficacité du mélangeur est améliorée:\n    Mais on peut faire mieux!\n  Comment modifier notre mélangeur pour ne pas utiliser remove?\n  On pourrait alors avoir:\n    Pour écrire du code effiace, il faut:\n savoir quelles opérations sont coûteuses sur notre structure de données    "},{"id":12,"href":"/modelisation/json/modele/","title":"Notion de modèle","section":"Modéliser en JSON","content":"Notion de modèle Notion de modèle   Un modèle est une classe qui représente des données importantes pour un programme\n  Prenons par exemple un petit tableau de cartes issu de l\u0026rsquo;atelier 1.1:\n  Le modèle est la classe MonTriLibre\n  Il faut aussi les objets Carte pour bien représenter les données\n  Les classes complémentaires comme Carte sont parfois appelées des valeurs (ou des sous-modèles)\n  Un modèle a des comportements (méthodes)   Comme MonTriLibre est une classe, le modèle contient aussi des méthodes\n  Par exemple:\n boolean isSorted pour déterminer si les cartes sont triées int testCaseSize qui retourne la taille de l\u0026rsquo;exemple (le nombre de cartes)    La valeur Carte contient aussi des méthodes, par exemple:\n int compareTo pour indiquer si la carte est plus petite qu\u0026rsquo;une autre carte boolean isNullCard pour indier s\u0026rsquo;il s\u0026rsquo;agit vraiment d\u0026rsquo;une carte ou d\u0026rsquo;une case vide    On va voir à la session suivante qu\u0026rsquo;une application graphique est souvent divisée en trois parties:\n le modèle: contient les données et les méthodes pour manipuler les données la vue: contient le code pour afficher les données le contrôleur: contient le code pour créer les vues et les modèles et autres tâches    Une application a souvent plusieurs modèles   Par exemple, l\u0026rsquo;outil de validation a un modèle a trois modèles\n un modèle pour les cartes et un pour les cas de tests   un modèle pour des paramètres    Modèle en JSON   JSON n\u0026rsquo;a pas de notion de classe\n  Dans ce cours, on va utiliser la clé spéciale _C pour identifier la classe\n  On a donc la représentation JSON suivante pour un 4♧:\n{ \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;, \u0026#34;numero\u0026#34;: 4, \u0026#34;sorte\u0026#34;: \u0026#34;TREFLE\u0026#34; }   Et le JSON suivant pour une liste de trois cartes\n[ { \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;, \u0026#34;numero\u0026#34;: 5, \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34; }, { \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;, \u0026#34;numero\u0026#34;: 4, \u0026#34;sorte\u0026#34;: \u0026#34;TREFLE\u0026#34; }, { \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;, \u0026#34;numero\u0026#34;: 6, \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34; } ]   Et finalement le JSON suivant pour le modèle MonTriLibre\n  { \u0026#34;_C\u0026#34;: \u0026#34;MonTriLibre\u0026#34;, \u0026#34;cartes\u0026#34;: [ { \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;, \u0026#34;numero\u0026#34;: 5, \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34; }, { \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;, \u0026#34;numero\u0026#34;: 4, \u0026#34;sorte\u0026#34;: \u0026#34;TREFLE\u0026#34; }, { \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;, \u0026#34;numero\u0026#34;: 6, \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34; } ], \u0026#34;siTrie\u0026#34;: false } "},{"id":13,"href":"/modelisation/recursivite/pile_appel/","title":"Pile d'appel","section":"Récursivité","content":"Pile d\u0026rsquo;appel  C\u0026rsquo;est quand une methode() fait un appel à elle-même:  public void methode(){ /* ... */ methode(); /* ... */ }   Le résultat est une boucle\n  Plusieurs algorithmes sont plus faciles à coder de cette façon\n c\u0026rsquo;est souvent plus proche de la définition papier (mathématique)    Par exemple:\n  définition mathématique de la fonction factorielle:\n fac(0) = 1 fac(n) = n * fac(n-1)    code Java récursif:\n    public int factoriel(int n){ if(n == 0){ return 1; }else{ return n * factoriel(n-1); } }   NOTE: le prof ignore volontairement le guide de style en faisant deux return\n  Il est toujours possible de transformer des appels récursifs en boucle normale\n  public int factoriel(int n){ int resultat; if(i == 0){ resultat = 1; }else{ resultat = n; for(int i = n-1; i \u0026gt; 0; i--){ resultat = resulat * i; } } return resultat; }  NOTE: on voit comment la code est plus loin de la définition mathématique  Pile d\u0026rsquo;appel   La récursivité utilise la pile d\u0026rsquo;appels pour mémoriser des valeurs\n  Qu\u0026rsquo;est-ce que la pile d\u0026rsquo;appels?\n quand on fait un appel de méthode, les arguments sont stoqués sur la pile quand la méthode termine, c\u0026rsquo;est retiré de la pile la pile permet de revenir là où on était dans la méthode précédente    Par exemple:\n  public static void A(int x, int y){ B(\u0026#34;a\u0026#34;); } public static void B(String c){ C(new char[]{\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;}); } public static void C(char[] tab){ } public static void main(String[] args){ A(0,1); // La pile va être  //  // au début: main()  // appel de A: main(), A(0,1)  // appel de B: main(), A(0,1), B(\u0026#34;a\u0026#34;)  // appel de C: main(), A(0,1), B(\u0026#34;a\u0026#34;), C({\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;})  // retour de C: main(), A(0,1), B(\u0026#34;a\u0026#34;)  // retour de B: main(), A(0,1)  // retour de A: main() }   En cas de plantage, la pile d\u0026rsquo;appel est affichée (équivalent de la ligne 24):\n Exception in thread \u0026quot;main\u0026quot; java.lang.RuntimeException at Pile.C(Pile.java:15) at Pile.B(Pile.java:11) at Pile.A(Pile.java:6) at Pile.main(Pile.java:20)    Avantages de la récursivité   Code souvent plus simple et plus lisible\n  Les boucles infinies sont détectées par des erreurs de débordement de pile\n  en anglais: stack overflow\n Exception in thread \u0026quot;main\u0026quot; java.lang.StackOverflowError at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) ...      Inconvénient de la récursivité   Plus facile d\u0026rsquo;écrire des boucles infinies (condition d\u0026rsquo;arrêt implicite)\n  En pratique, la pile d\u0026rsquo;appel est assez petite (p.ex. 1000 appels)\n donc souvent impossible d\u0026rsquo;utiliser la récursivité sur des gros problèmes    Transformer en boucle normale   On peut transformer n\u0026rsquo;importe quelle méthode récursive en boucle\n  On peut écrire du code récursif pour un prototype\n et éliminer la récursivité pour le code de production    Certains compilateurs peuvent éliminer automatiquement la récursivité\n à condition que l\u0026rsquo;appel récursif soit la toute dernière instruction de la méthode    public int factoriel(int n){ return factoriel(n, 1); } public int factoriel(int n, int courant){ if(n == 0){ return courant; }else{ return factoriel(n-1, n * courant); } } "},{"id":14,"href":"/preface/","title":"Préface","section":"Cartes Java","content":"Préface "},{"id":15,"href":"/modelisation/java/structures/","title":"Structures en Java","section":"Modéliser en Java","content":"Structures en Java  NOTE:\n on va voir les paramètres de types plus en détail à l\u0026rsquo;étape 3     Le JDK Java contient plusieurs structures de données déjà codées\n  Dans ce cours, on va se concentrer sur les deux principales:\n List\u0026lt;E\u0026gt;: une liste Map\u0026lt;K,V\u0026gt;: un dictionnaire (mappage)    À partir de maintenant, vous devriez:\n presque toujours utiliser une List\u0026lt;Integer\u0026gt; et jamais un tableau int[] presque toujours utiliser les structures fournies dans le JDK Java    Exception: pour des raisons pédagogiques\n p.ex. pour comprendre comment coder une liste    Exception: dans des cas bien précis où on a besoin de notre propre structure de données\n p.ex. liste d\u0026rsquo;objets 2d conçue pour détection de collision    List\u0026lt;E\u0026gt;: liste en Java  Exemple d\u0026rsquo;utilisation:  // interface implantation  List\u0026lt;String\u0026gt; listeChaines = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Double\u0026gt; listeReels = new LinkedList\u0026lt;\u0026gt;(); listeChaines.add(\u0026#34;sdf\u0026#34;); // ajoute à la fin listeChaines.add(\u0026#34;34g\u0026#34;); listeChaines.add(\u0026#34;j554\u0026#34;); listeChaines.add(9,\u0026#34;asdf\u0026#34;); // nouvel élément listeChaines.set(9,\u0026#34;asdf\u0026#34;); // change la valeur  String chaine = listeChaines.get(2);  Extrait de l\u0026rsquo;interface:  public interface List\u0026lt;E extends Object\u0026gt; extends Collection\u0026lt;E\u0026gt;{ boolean add(E e); // ajoute à la fin  void add(int i, E e); // insère une nouvelle valeur à la position i  void set(int i, E e); // modifie la valeur à la position i  E get(int i); // obtenir la valeur à la position i  void clear(); // vide la liste  int size(); // taille de la liste  boolean isEmpty(); // si vide  boolean contains(Object o); // si la liste contient la valeur o  int indexOf(Object o); // indice de la valeur o  //... }  Documentation complète:  https://docs.oracle.com/javase/8/docs/api/java/util/List.html    Implantations de List\u0026lt;E\u0026gt;   List\u0026lt;E\u0026gt; est une interface\n  Le JDK Java fournit différentes implantations, p.ex:\n ArrayList\u0026lt;E\u0026gt; LinkedList\u0026lt;E\u0026gt;    Pour l\u0026rsquo;instant, on va utiliser ArrayList\u0026lt;E\u0026gt;\n  Quelle est la différence?\n à utiliser: aucune (c\u0026rsquo;est la même interface) en terme d\u0026rsquo;efficacité? à coder?  on va en parler à l\u0026rsquo;étape 4      Map\u0026lt;K,V\u0026gt;: mappage en Java   Les clés d\u0026rsquo;un mappage peuvent être de n\u0026rsquo;importe quel type\n contrairement à notre Dictionnaire où les clés étaients toujours des chaînes    Il y a deux paramètres de types:\n K: le type des clés V: le type des valeurs    IMPORTANT: une clé est associée à une seule valeur\n  Exemple d\u0026rsquo;utilisation:\n  // interface implantation  Map\u0026lt;String, Object\u0026gt; objetJson = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Integer, String\u0026gt; parDA = new TreeMap\u0026lt;\u0026gt;(); Map\u0026lt;StudentId, Billet\u0026gt; rendezVous = new LinkedHashMap\u0026lt;\u0026gt;(); objetJson.put(\u0026#34;attr01\u0026#34;, true); objetJson.put(\u0026#34;attr02\u0026#34;, null); objetJson.put(\u0026#34;attr03\u0026#34;, 123.4); Object valeur01 = objetJson.get(\u0026#34;attr01\u0026#34;); parDA.put(421235, \u0026#34;Amina\u0026#34;); parDA.put(413354, \u0026#34;Bénison\u0026#34;); parDA.put(565624, \u0026#34;Carlos\u0026#34;); parDA.put(645143, \u0026#34;Delpine\u0026#34;); String nomEtudiant = parDA.get(413354); StudentId id = new StudentId(645143); rendezVous.put(id, new rendezVous()); rendezVous.get(id);   NOTE: on utilise la notation \u0026lt;P1, P2\u0026gt; quand il y a plusieurs paramètres de type\n  Extrait de l\u0026rsquo;interface:\n  public interface Map\u0026lt;K extends Object, V extends Object\u0026gt; { V put(K c, V v); // associe la valeur v à la clé c  V get(K c); // obtenir la valeur associée à la clé c  void clear(); // vide le map  int size(); // taille du map  boolean isEmpty(); // si vide  boolean containsKey(Object c); // si le map contient la clé c  boolean containsValue(Object v); // si le map contient la valeur v  //... }  Documentation complète:  https://docs.oracle.com/javase/8/docs/api/java/util/Map.html    Implantations de Map\u0026lt;K,V\u0026gt;   Le JDK Java fournit différentes implantations, p.ex:\n HashMap\u0026lt;K,V\u0026gt; TreeMap\u0026lt;K,V\u0026gt; LinkedHashMap\u0026lt;K,V\u0026gt;    Quelle est la différence?\n à utiliser: presqu\u0026rsquo;aucune (*) à coder? en terme d\u0026rsquo;efficacité?  on en parle à l\u0026rsquo;étape 5      (*) LinkedHashMap est un cas spécial:\n en plus d\u0026rsquo;implanter l\u0026rsquo;interface Map\u0026lt;K,V\u0026gt;, on ajoute la promesse suivante:  il est possible d\u0026rsquo;accéder aux clés dans l\u0026rsquo;ordre où elles ont été insérées      Encoder des données JSON en Java   Une liste JSON est représenté en Java par List\u0026lt;Object\u0026gt;\n  Un objet JSON est représenté en Java par Map\u0026lt;String, Object\u0026gt;\n  Par exemple:\n  { \u0026#34;_C\u0026#34;: \u0026#34;MesDonneesJson\u0026#34;, \u0026#34;racine\u0026#34;: { \u0026#34;vehicules\u0026#34;: [ { \u0026#34;nombreDeRoues\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;mobilette\u0026#34;, \u0026#34;etat\u0026#34;: { \u0026#34;besoinChangementHuile\u0026#34;: false, \u0026#34;kilometrage\u0026#34;: 14.45 } }, { \u0026#34;nombreDeRoues\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;camion\u0026#34;, \u0026#34;etat\u0026#34;: { \u0026#34;besoinChangementHuile\u0026#34;: true, \u0026#34;kilometrage\u0026#34;: 13344.5 } } ] } } public class MesDonneesJava extends DonneesJava { @Override public void initialiser(){ Map\u0026lt;String, Object\u0026gt; laRacine = new HashMap\u0026lt;\u0026gt;(); this.setRacine(laRacine); List\u0026lt;Object\u0026gt; lesVehicules = new ArrayList\u0026lt;\u0026gt;(); laRacine.put(\u0026#34;vehicules\u0026#34;, lesVehicules); Map\u0026lt;String, Object\u0026gt; vehicule01 = new HashMap\u0026lt;\u0026gt;(); lesVehicules.add(vehicule01); vehicule01.put(\u0026#34;nombreDeRoues\u0026#34;, 2); vehicule01.put(\u0026#34;type\u0026#34;, \u0026#34;mobilette\u0026#34;); Map\u0026lt;String, Object\u0026gt; etat01 = new HashMap\u0026lt;\u0026gt;(); vehicule01.put(\u0026#34;etat\u0026#34;, etat01); etat01.put(\u0026#34;kilometrage\u0026#34;,14.45); etat01.put(\u0026#34;besoinChangementHuile\u0026#34;,false); Map\u0026lt;String, Object\u0026gt; vehicule02 = new HashMap\u0026lt;\u0026gt;(); lesVehicules.add(vehicule02); vehicule02.put(\u0026#34;nombreDeRoues\u0026#34;, 4); vehicule02.put(\u0026#34;type\u0026#34;, \u0026#34;camion\u0026#34;); Map\u0026lt;String, Object\u0026gt; etat02 = new HashMap\u0026lt;\u0026gt;(); vehicule02.put(\u0026#34;etat\u0026#34;, etat02); etat02.put(\u0026#34;kilometrage\u0026#34;,13344.5); etat02.put(\u0026#34;besoinChangementHuile\u0026#34;,true); } } "},{"id":16,"href":"/modelisation/java/references_multiples/","title":"Visualiser les références multiples","section":"Modéliser en Java","content":"Visualiser les références multiples Typiquement, on va copier une référence à un objet, plutôt que déplacer l\u0026rsquo;objet.\n   Typique   Plus rare     memoireA = cartes[0];   memoireA = cartes[0]; cartes[0] = null;    Le résultat est qu\u0026rsquo;on a des références multiples: plusieurs références vers le même objet.\nSi on visualise du code typique avec les cartes, on va visualiser les références multiples en affichant plusieurs copies d\u0026rsquo;une carte.\n   La visualisation est correcte, mais plus difficile à lire.\nAutant que possible, on va expliquer les procédures en déplaçant les cartes, c\u0026rsquo;est-à-dire en évitant de créer des références multiples. Cependant, il faut garder en tête que le code typique contient très souvent des références multiples.\n"},{"id":17,"href":"/procedures/windows/eclipse/","title":"Procédure: installer Eclipse","section":"Windows","content":"Procédure: installer Eclipse  Rappel: ne pas effectuer cette étape sur un Windows du Collège     Recomandé: désinstaller toute ancienne version d\u0026rsquo;Eclipse\n  Installer Eclipse (version 2022-06 ou plus récent)\n Visiter https://www.eclipse.org/downloads/ Télécharger en cliquant sur Download x86_64 Exécuter eclipse-inst-win64.exe Installer Eclipse IDE for Java Developers avec les options par défaut    Configurer Eclipse  --   Je démarre Eclipse\n Je choisi mon WORKSPACE, p.ex.  Z:\\eclipse-workspace (Windows du Collège) C:\\Users\\PRENOM_NOM\\eclipse-workspace (Mon Windows)      Je m\u0026rsquo;assure que Eclipse utilise le JDK 11\n  Window =\u0026gt; Preferences\n  Java =\u0026gt; Installed JREs\n    Idéallement, Eclipse utilise uniquement le JDK 11\n  Si j\u0026rsquo;en ai pas besoin, je fait Remove sur tous les JDK sauf 11\n  Si le JDK 11 n\u0026rsquo;est pas là, je l\u0026rsquo;ajoute:\n Add =\u0026gt; Standard VM =\u0026gt; Next Sélectionner le répertoire racine du JDK, p.ex:  C:\\Program Files\\Java\\jdk-11.XXX   Finish Apply and Close    Je m\u0026rsquo;assure que le JDK 11 est le défaut (en gras)\n    "},{"id":18,"href":"/procedures/windows/git/","title":"Procédure: installer Git","section":"Windows","content":"Procédure: installer Git  Rappel: ne pas effectuer cette étape sur un Windows du Collège    Visiter https://git-scm.com/download/win Télécharger et et exécuter Git-2.37.2.2-64-bit.exe Installer avec les options par défaut, sauf:  Recommandé: choisir nano comme éditeur plutôt que vim:       "},{"id":19,"href":"/procedures/windows/jdk11/","title":"Procédure: installer le JDK 11","section":"Windows","content":"Procédure: installer le JDK 11   Si ce n\u0026rsquo;est pas déjà fait, créer un compte Oracle: https://profile.oracle.com/myprofile/account/create-account.jspx\n  Visiter https://www.oracle.com/java/technologies/javase/jdk11-archive-downloads.html\n  Télécharger la version Windows x64 Installer\n jdk-11.0.16_windows-x64_bin.exe    Accepter la licence et je clique sur Download\n  Exécuter jdk-11.0.16_windows-x64_bin.exe\n  Installer avec les options par défaut\n  "},{"id":20,"href":"/procedures/gitlab/inscription/","title":"Procédure: s'inscrire à GitLab","section":"Gitlab","content":"Procédure: s\u0026rsquo;inscrire à GitLab   Visiter https://gitlab.com\n Cliquer sur Register    Remplir le formulaire\n  Cliquer sur Je ne suis pas un robot\n  Cliquer sur Register\n    Attendre le courriel de confirmation\n Cliquer sur le lien dans le courriel pour confirmer l\u0026rsquo;inscription    "},{"id":21,"href":"/efficacite/temps01/","title":"Efficacité en temps (1)","section":"Qu'est-ce que l'efficacité?","content":"Efficacité en temps (1)   Performance: le temps que le programme prend pour s\u0026rsquo;exécuter\n se mesure en secondes va varier selon les options de compilation va varier selon comment la mémoire est gérée  p.ex. Java gère automatiquement la mémoire, ce qui peut entraîner des pauses      Efficacité: le nombre d\u0026rsquo;instructions que le programme va exécuter\n est estimé en analysant le code n\u0026rsquo;est pas relié à la longueur du code:  du code plus court peut exécuter beaucoup plus d\u0026rsquo;instructions   c\u0026rsquo;est la tendance qui est importante:  est-ce que les instructions explosent sur des grosses données?      La relation entre les deux est à sens unique:\n un programme performant doit d\u0026rsquo;abord être efficace un programme efficace n\u0026rsquo;est pas nécessairement performant  p.ex. si la machine manque de mémoire      On va voir deux exemples:\n rechercher dans un tableau trier un tableau    Performance   Voici les trois lois de l\u0026rsquo;optimisation de performance:\n Première loi: ne jamais tenter d\u0026rsquo;optimiser la performance Deuxième loi: ne jamais tenter d\u0026rsquo;optimiser la performance Troisième loi (pour expert): ne jamais tenter d\u0026rsquo;optimiser la performance    Il y a aussi la fameuse citation de Knuth:\n \u0026ldquo;Premature optimization is the root of all evil\u0026rdquo; (L\u0026rsquo;optimisation prématurée est la cause de toutes nos souffrance).    Pourquoi?\n  Raison 1) optimiser le temps d\u0026rsquo;exécution est vraiment, vraiment difficile\n (p.ex. il faut bien connaître les détails de la machine qu\u0026rsquo;on veut utiliser)    Raison 2) les programmeurs se trompent souvent sur comment optimiser\n à vouloir \u0026ldquo;optimiser\u0026rdquo;, on se retrouve trop souvent avec du code illisible:    public int trouverIndicePourValeur(Tableau tab, Comparable v) { int i,l; for(i=0,l=l(tab);l\u0026gt;0;i=eq(v,v(tab,i%l(tab)))?(--l\u0026gt;0?i++:i):++i); return i; }   En passant:\n Il s\u0026rsquo;agit de code Java valide Le code fonctionne et retourne les bonnes valeurs Par contre, il y a une erreur de logique qui affecte son efficacité Qui veut trouver l\u0026rsquo;erreur et la corriger?    Évidemment, il y a quand même des cas où il faut optimiser\n en général, c\u0026rsquo;est effectué une fois que le programme fonctionne bien  c\u0026rsquo;est un autre projet, possiblement effectué par une autre équipe   il faut mesurer (profiler) le programme pour comprendre ce qui bloque souvent, on optimise pour une seule plateforme matérielle à la fois  p.ex. optimiser du code réseau pour un modèle précis de routeur      Efficacité   Contrairement à la performance, il faut se soucier d\u0026rsquo;efficacité dès que possible\n  C\u0026rsquo;est heureusement beaucoup plus facile. Il faut:\n choisir les bonnes structures de données choisir les bons algorithmes (90% du temps, il suffit d\u0026rsquo;utiliser du code de librairie)    L\u0026rsquo;efficacité n\u0026rsquo;est pas reliée à la longueur du code, mais bien à comment il s\u0026rsquo;exécute\n  Par exemple, voici une autre méthode de recherche:\n  public int trouverIndicePourValeur(Tableau tableau, Comparable valeur) { int indice = -1; for(int i = 0; i \u0026lt; tableau.longueur(); i++) { if(tableau.obtenirValeur(i).compareTo(valeur) == 0) { indice = i; } } return indice; }  Cette fois-ci, le code est plus lisible:  on peut vérifier qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;erreur de logique le code est d\u0026rsquo;ailleurs plus efficace que le précédent    Théorie de l\u0026rsquo;efficacité (complexité)   Il y a beaucoup de théorie au sujet de l\u0026rsquo;efficacité (appelée souvent complexité)\n  En gros, il faut regarder la tendance lorsque le programme traite beaucoup de données\n si le nombre d\u0026rsquo;instructions n\u0026rsquo;augmente pas trop, le programme est efficace si le nombre d\u0026rsquo;instructions explose, alors le programme n\u0026rsquo;est pas efficace    Considérer p.ex. un programme pour trier un tableau:\n  Le graphique ci-haut montre la taille des tableaux à trier et le temps d\u0026rsquo;exécution en secondes\n  Le programme semble efficace pour les tableaux de tailles 1000 à 30700\n les temps d\u0026rsquo;exécution vont de ~0 secondes à ~3 secondes    Pour être vraiment considérer efficace, il faudrait que la tendance soit une droite:\n  Le cas où c\u0026rsquo;est une droite est appelé linéaire\n  Malheureusement, ce n\u0026rsquo;est pas le cas ici est le programme n\u0026rsquo;est pas efficace:\n  Le cas où c\u0026rsquo;est plutôt une courbe montante est appelé quadratique ou polynomial\n on voit que quand la taille du tableau augmente, le temps d\u0026rsquo;exécution explose    En résumé: l\u0026rsquo;efficacité concerne les tendances et non des mesures exactes de performances\n  Notation O()   La notation O(n) est souvent utilisée pour parler d\u0026rsquo;efficacité\n O() veut dire: le nombre d\u0026rsquo;instructions est à peu près n est la taille de l\u0026rsquo;entrée (p.ex. nombre d\u0026rsquo;éléments à trier)    Par exemple:\n O(n): linéaire  le nombre d\u0026rsquo;instructions est similaire à la taille n de l\u0026rsquo;entrée   O(n2): quadratique  le nombre d\u0026rsquo;instructions est environs le carré de la taille n de l\u0026rsquo;entrée   O(2n): exponentiel  le nombre d\u0026rsquo;instructions explose comme si n était un exposant      En général, O(n) est considéré comme efficace, mais pas O(n2):\n     Finalement, O(2n) est rarement utilisable en pratique:  la croissance est tellement rapide qu\u0026rsquo;en comparaison O(n2) ne semble même pas croître       Pour estimer le nombre d\u0026rsquo;instructions, il faut multiplier par 2 à chaque étape:  si n=12, on a:  instructions à effectuer à la 1ière étape: 1 instructions à effectuer à la 2ième étape: 2 instructions à effectuer à la 3ième étape: 4 instructions à effectuer à la 4ième étape: 8 instructions à effectuer à la 5ième étape: 16 instructions à effectuer à la 6ième étape: 32 instructions à effectuer à la 7ième étape: 64 instructions à effectuer à la 8ième étape: 128 instructions à effectuer à la 9ième étape: 256 instructions à effectuer à la 10ième étape: 512 instructions à effectuer à la 11ième étape: 1024 instructions à effectuer à la 12ième étape: 2048   dès que n est le moindrement grand, le nombre d\u0026rsquo;instructions est ingérable p.ex. n=32 veut déjà dire 4294967296 (4 milliards d\u0026rsquo;instructions) p.ex. n=300 veut déjà dire 2·1090 (plus que le nombre d\u0026rsquo;atomes dans l\u0026rsquo;univers)    Comparaison de nos deux trouverIndicePourValeur  Reconsidérons nos deux trouverIndicePourValeur  public int trouverIndicePourValeur(Tableau tab, Comparable v) { int i,l; for(i=0,l=l(tab);l\u0026gt;0;i=eq(v,v(tab,i%l(tab)))?(--l\u0026gt;0?i++:i):++i); return i; } public int trouverIndicePourValeur(Tableau tableau, Comparable valeur) { int indice = -1; for(int i = 0; i \u0026lt; tableau.longueur(); i++) { if(tableau.obtenirValeur(i).compareTo(valeur) == 0) { indice = i; } } return indice; }  En pratique, quelle est la différence d\u0026rsquo;efficacité entre les deux?      Les deux sembles linéaires, mais une version est clairement moins performante que l\u0026rsquo;autre\n  En passant, voici comment corriger l\u0026rsquo;erreur logique dans la première version:\n  public int trouverIndicePourValeur(Tableau\u0026lt;C\u0026gt; tab, C v) { int i,l; for(i=0,l=l(tab);--l\u0026gt;0;i=eq(v,v(tab,i))?i:++i); return i; }   C\u0026rsquo;est clair, non?\n  Voici la performance de la version corrigée:\n  À noter que le code \u0026ldquo;raccourci\u0026rdquo; performe exactement comme le code \u0026ldquo;au long\u0026rdquo;\n  Écrire le code le plus court possible n\u0026rsquo;a pas d\u0026rsquo;impact sur la performance\n  Ce qui a un impact est d\u0026rsquo;écrire du code efficace\n  "},{"id":22,"href":"/intro/","title":"Introduction","section":"Cartes Java","content":"Introduction "},{"id":23,"href":"/approche/ntro/","title":"Librairie Ntro","section":"Présentation de l'approche","content":"Outils pour enseigner la programmation Code source: github.com/mathieu-bergeron\nPrononcé «intro», Ntro est conçu pour les novices sachant déjà programmer, mais éprouvant certaines difficultés à:\n imaginer comment les données sont organisées en mémoire imaginer les différentes tâches effectuées par le programme et leurs interdépendances décortiquer les messages d\u0026rsquo;erreurs de Java réfléchir à l\u0026rsquo;efficacité du programme modéliser les données d\u0026rsquo;une application (créer des modèles)  Auto-valider un atelier de façon interactive   Code source: github.com/mathieu-bergeron/validation_de_tutoriels\nVisualiser les structures de données   Visualiser l\u0026rsquo;efficacité d\u0026rsquo;une structure de données   Visualiser le modèle d\u0026rsquo;une application graphique     Visualiser les tâches d\u0026rsquo;une application graphique   "},{"id":24,"href":"/mappage/hachage/","title":"Mappage par hachage","section":"Comprendre les mappages","content":"Mappage par hachage   Un map permet d\u0026rsquo;associer une clé à une valeur\n chaque clé est unique    Par exemple, le map ci-bas associe la clé \u0026quot;xdf\u0026quot; à la valeur 12:\n {\u0026quot;sdx\u0026quot;:5,\u0026quot;xdf\u0026quot;:12,\u0026quot;lkm\u0026quot;:54}    Un map est aussi appelé: dictionnaire, liste associative, objet JSON\n  On peut voir un map comme un tableau où les indices ne sont pas des entiers:\n  // Java valide Character[] tableauChar = new String[3]; tableauChar[0] = \u0026#39;a\u0026#39;; // l\u0026#39;indice est un entier tableauChar[1] = \u0026#39;b\u0026#39;; tableauChar[2] = \u0026#39;c\u0026#39;; // 0 1 2 // [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;]  // Ce qu\u0026#39;on aimerais avoir (pas du Java valide) \u0026lt;String, Character\u0026gt;[] mapChar; mapChar = new \u0026lt;String, Character\u0026gt;[3]; mapChar[\u0026#34;premier\u0026#34;] = \u0026#39;a\u0026#39;; // l\u0026#39;indice est une chaîne! mapChar[\u0026#34;deuxième\u0026#34;] = \u0026#39;b\u0026#39;; mapChar[\u0026#34;troisième\u0026#34;] = \u0026#39;c\u0026#39;; // \u0026#34;premier\u0026#34; \u0026#34;deuxième\u0026#34; \u0026#34;troisième\u0026#34; // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]  Interface d\u0026rsquo;un map public interface MapJava\u0026lt;C extends Cle\u0026lt;?\u0026gt;, V extends Object\u0026gt; { void put(C c, V v); // associe la valeur v à la clé c \tV get(C c); // obtenir la valeur associée à la clé c \tvoid clear(); // vide le map \tint size(); // taille du map \tboolean isEmpty(); // si vide \tboolean containsKey(C c); // si le map contient la clé c \tboolean containsValue(V v); // si le map contient la valeur v \tvoid remove(C c); // effacer la clé c (et la valeur associée) \tList\u0026lt;C\u0026gt; keys(); // retourner une liste de clés  } Implantation naïve d\u0026rsquo;un map   On utilise deux listes:\n la liste des clés la liste des valeurs    Une paire clé/valeur est mémorisée au même indice\n  Par exemple:\n Si la clé \u0026quot;xdf\u0026quot; est à l\u0026rsquo;indice 1 dans cles Alors la valeur associée à \u0026quot;xdf\u0026quot; est aussi à l\u0026rsquo;indice 1, mais dans valeurs    // Le map {\u0026#34;sdx\u0026#34;:5,\u0026#34;xdf\u0026#34;:12,\u0026#34;lkm\u0026#34;:54} // Les clés // 0 1 2 cles = [\u0026#34;sdx\u0026#34;,\u0026#34;xdf\u0026#34;,\u0026#34;lkm\u0026#34;] // Les valeurs // 0 1 2 valeurs = [5, 12, 54]  En général:  public class MapJavaNaif \u0026lt;C extends Cle\u0026lt;?\u0026gt;, V extends Object\u0026gt; extends MapJava\u0026lt;C,V\u0026gt; { private List\u0026lt;C\u0026gt; cles = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;V\u0026gt; valeurs = new ArrayList\u0026lt;\u0026gt;(); @Override public void put(C c, V v) { int indiceCle = cles.indexOf(c); if(indiceCle != -1) { valeurs.set(indiceCle, v); }else { cles.add(c); valeurs.add(v); } } @Override public V get(C c) { V valeur = null; int indiceCle = cles.indexOf(c); if(indiceCle != -1) { valeur = valeurs.get(indiceCle); } return valeur; } @Override public void remove(C c) { int indiceCle = cles.indexOf(c); if(indiceCle != -1) { cles.remove(indiceCle); valeurs.remove(indiceCle); } } @Override public List\u0026lt;C\u0026gt; keys() { return cles; } }   Chaque clé doit héritée de la classe Cle:\n on veut ainsi rendre explicite la notion de clé    public class Cle\u0026lt;T extends Object\u0026gt; { private T valeurJava; public Cle(T valeurJava) { this.valeurJava = valeurJava; } public T valeurJava() { return valeurJava; } } Problème d\u0026rsquo;efficacité  Modifier une valeur dans notre map naïf n\u0026rsquo;est pas efficace:      Le problème est que indexOf fait une boucle sur la liste des clés\n  Mais on aimerait que ça soit efficace:\n on veut utiliser le map comme un tableau    Fonction et table de hachage   On veut éviter de chercher l\u0026rsquo;indice de la clé avec un indexOf\n  On utiliser une fonction de hachage, c-à-d une méthode qui va\n calculer un indice pour chaque clé sans chercher d\u0026rsquo;information sur les autres clés    Une clé hachable doit implanter la méthode indice qui retourne l\u0026rsquo;indice de la clé\n  public abstract class CleHachable \u0026lt;T extends Object\u0026gt; extends Cle\u0026lt;T\u0026gt; { public CleHachable(T valeurJava) { super(valeurJava); } public abstract int indice(); }   Voici par exemple une clé hachable quand la clé est une chaîne:\n l\u0026rsquo;indice est simplement la longueur de la clé    public class ChaineHashb extends CleHachable\u0026lt;String\u0026gt; { public ChaineHashb(String valeurJava) { super(valeurJava); } @Override public int indice() { return valeurJava().length(); } }  Une fois qu\u0026rsquo;on a un indice, on peut mémoriser la valeur dans un tableau  List\u0026lt;Character\u0026gt; valeurs = new ArrayList\u0026lt;\u0026gt;(); cle01 = new ChaineHashb(\u0026#34;v\u0026#34;); cle02 = new ChaineHashb(\u0026#34;yf\u0026#34;); cle03 = new ChaineHashb(\u0026#34;asf\u0026#34;); map.put(cle01, \u0026#39;a\u0026#39;): // la clé est \u0026#34;v\u0026#34;, l\u0026#39;indice est 1 (la longueur)  int indice01 = cle01.indice(); valeurs.set(indice01, \u0026#39;a\u0026#39;); map.put(cle02, \u0026#39;b\u0026#39;): // la clé est \u0026#34;yf\u0026#34;, l\u0026#39;indice est 2 (la longueur)  int indice02 = cle02.indice(); valeurs.set(indice02, \u0026#39;b\u0026#39;); map.put(cle03, \u0026#39;c\u0026#39;): // la clé est \u0026#34;asf\u0026#34;, l\u0026#39;indice est 3 (la longueur)  int indice03 = cle03.indice(); valeurs.set(indice03, \u0026#39;c\u0026#39;);  IMPORTANT: la fonction de hachage ne doit pas être aléatoire  sinon on ne peut plus retrouver une valeur mémorisée par indice!    Quoi faire en cas de collision?  Quoi faire s\u0026rsquo;il y a une collision, c-à-d si deux clés ont le même indice?  List\u0026lt;Character\u0026gt; valeurs = new ArrayList\u0026lt;\u0026gt;(); cle01 = new ChaineHashb(\u0026#34;x\u0026#34;); cle02 = new ChaineHashb(\u0026#34;y\u0026#34;); map.put(cle01, \u0026#39;a\u0026#39;): // la clé est \u0026#34;x\u0026#34;, l\u0026#39;indice est 1 (la longueur)  int indice01 = cle01.indice(); valeurs.set(indice01, \u0026#39;a\u0026#39;); map.put(cle02, \u0026#39;b\u0026#39;): // la clé est \u0026#34;y\u0026#34;, l\u0026#39;indice est encore 1!  int indice02 = cle02.indice(); valeurs.set(indice02, \u0026#39;b\u0026#39;); // oups! On vient d\u0026#39;écraser la paire \u0026#34;x\u0026#34;:\u0026#39;a\u0026#39;    En fait, on ne peut pas associer un indice directement à une valeur\n  Il faut plutôt associer l\u0026rsquo;indice à un map naïf:\n  MapJava\u0026lt;Cle,Character\u0026gt;[] valeurs = new MapJava\u0026lt;Cle,Character\u0026gt;[1000]; cle01 = new ChaineHashb(\u0026#34;x\u0026#34;); cle02 = new ChaineHashb(\u0026#34;y\u0026#34;); cle03 = new ChaineHashb(\u0026#34;z\u0026#34;); map.put(cle01, \u0026#39;a\u0026#39;): // la clé est \u0026#34;x\u0026#34;, l\u0026#39;indice est 1 (la longueur)  int indice01 = cle01.indice(); // insérer d\u0026#39;abord un map à l\u0026#39;indice  valeurs[indice01] = new MapJavaNaif\u0026lt;\u0026gt;(); valeurs[indice01].put(cle01, \u0026#39;a\u0026#39;); map.put(cle02, \u0026#39;b\u0026#39;): // la clé est \u0026#34;y\u0026#34;, l\u0026#39;indice est encore 1  int indice02 = cle02.indice(); valeurs[indice02].put(cle02, \u0026#39;b\u0026#39;); map.put(cle03, \u0026#39;c\u0026#39;): // la clé est \u0026#34;z\u0026#34;, l\u0026#39;indice est encore 1  int indice03 = cle03.indice(); valeurs[indice03].put(cle03, \u0026#39;c\u0026#39;);   S\u0026rsquo;il n\u0026rsquo;y a pas souvent de collision:\n on accède aux valeurs surtout par indice le map naïf associé à l\u0026rsquo;indice va contenir très peu de valeurs c\u0026rsquo;est alors efficace    Au contraire, s\u0026rsquo;il y beaucoup de collisions:\n on accède presque toujours aux mêmes indices le map naïf associé à un indice va contenir beaucoup de valeurs on accède donc aux valeurs surtout en cherchant la clé c\u0026rsquo;est alors inefficace    Donc, une bonne fonction de hachage doit:\n retourner le plus souvent possible un indice différent retourner toujours le même indice pour la même clé (ne pas être aléatoire)    Implantation d\u0026rsquo;un map avec hachage  Voici le début de l\u0026rsquo;implantation  public class MapJavaHash \u0026lt;C extends CleHachable\u0026lt;?\u0026gt;, V extends Object\u0026gt; extends MapJava\u0026lt;C,V\u0026gt; { private static final int TAILLE_TABLE_HACHAGE = 1000; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private MapJavaNaif\u0026lt;C,V\u0026gt;[] table = new MapJavaNaif[TAILLE_TABLE_HACHAGE]; private int taille = 0;  IMPORTANT:  la méthode CleHachable.indice peut retourner un indice \u0026gt;= table.length il faut adapter l\u0026rsquo;indice à la table de notre tableau habituellement, on fait ça avec l\u0026rsquo;opérateur modulo %    Efficacité   L\u0026rsquo;efficacité dépend du nombre de collisions, ce qui dépend en fait de:\n la taille de la table de hachage la qualité de la fonction de hachage    On a encore le compromis temps/espace mémoire:\n pour obtenir plus d\u0026rsquo;efficacité en temps, on va utiliser plus d\u0026rsquo;espace mémoire    Exemple:\n     La fonction Hashc est très efficace, alors que  Hashb est un peu efficace Hasha équivaut à l\u0026rsquo;implantation naïve    "},{"id":25,"href":"/efficacite/temps02/","title":"Efficacité en temps (2)","section":"Qu'est-ce que l'efficacité?","content":"Efficacité en temps (2)   On peut estimer l\u0026rsquo;efficacité d\u0026rsquo;un programme en analysant son pseudo-code\n  Nous allons utiliser les exemples suivants:\n une recherche naïve: O(n) un tri naïf: O(n2) une recherche de type \u0026ldquo;diviser pour régner\u0026rdquo;: O(log(n)) le tri fusion: O(log(n)·n)    Estimer l\u0026rsquo;efficacité avec O()   Il faut se poser la question:\n pour chacun des n éléments en entrée:  combien de fois est-ce que l\u0026rsquo;élément sera manipulé?      Voici le pseudo-code d\u0026rsquo;un recherche naïve:\n  int trouverIndicePourValeur(tableau, valeur):\n POUR TOUS les éléments el du tableau:  SI el est égal à la valeur cherchée:  mémoriser l\u0026rsquo;indice i de l\u0026rsquo;élément el     retourner le dernier indice i mémorisé     Clairement, on va manipuler chaque élément une fois:\n on fait une boucle sur tout le tableau on compare chaque élément du tableau à la valeur cherchée    Donc, si on a n éléments en entrée, il y aura environs n instructions\n  Donc, l\u0026rsquo;efficacité (complexité) de l\u0026rsquo;algorithme est estimée à O(n)\n  Tri naïf: O(n2)  Voici le pseudo-code d\u0026rsquo;un algorithme de tri naïf:  Tableau\u0026lt;C\u0026gt; trier(Tableau\u0026lt;C\u0026gt; entree):\n CRÉER un tableau resultat vide TANT QUE le tableau entree n\u0026rsquo;est pas vide  appeler valeurMinimale et mémoriser la valeur de retour retirer cette valeur du tableau entree ajouter cette valeur à la fin du tableau resultat   retourner le tableau resultat     Si le tableau entree contient n éléments, la boucle va s\u0026rsquo;exécuter n fois\n à chaque tour de boucle, on retire un élément après n tours, entree sera vide et on va quitter la boucle    On va faire au moins n appels à valeurMinimale()\n  Le nombre d\u0026rsquo;instructions va être n·VM\n où VM est le nombre d\u0026rsquo;instructions pour chaque appel à valeurMinimale() le nombre d\u0026rsquo;instructions total est estimé à O(n·VM)    Regardons le pseudo-code de valeurMinimale():\n  Valeur obtenirValeurMinimale(tableau):\n considérer que le premier élément du tableau est la valeur minimale POUR TOUS les éléments el du tableau:  SI el est plus petit que la valeur minimale courante:  mémoriser el comme la nouvelle valeur minimale courante     retourner la valeur minimale     On visite chaque élément du tableau\n donc on va faire n instructions pour chaque appel à valeurMinimale() alors VM == n    En résumé:\n la boucle de trier fait n appels à valeurMinimale() chaque appel à valeurMinimale() fait n instructions on a donc O(n·VM) où VM == n on a donc O(n·n) on a donc O(n2)    L\u0026rsquo;efficacité (complexité) de notre tri naïf est O(n2)\n  Diviser pour régner: O(log(n))   On cherche une valeur dans un tableau trié de plus petit au plus grand\n  Est-ce qu\u0026rsquo;on est obligé de visiter tout le tableau?\n  On peut appliquer une technique appelée \u0026ldquo;diviser pour régner\u0026rdquo;:\n on choisit un élément au milieu du tableau si l\u0026rsquo;élément est plus petit que la valeur cherchée  on peut chercher uniquement \u0026ldquo;haut dessus\u0026rdquo; de cet élément   si au contraire l\u0026rsquo;élément est plus grand que la valeur cherchée  on peut chercher uniquement \u0026ldquo;en dessous\u0026rdquo; de cet élément      Et pour chercher dans la moitié du tableau?\n on applique encore \u0026ldquo;diviser pour régner\u0026rdquo; on cherche uniquement dans la moitié de la moitié du tableau    Et ainsi de suite jusqu\u0026rsquo;à ce qu\u0026rsquo;on trouve\n  À chaque étape dans notre recherche, on divise le tableau en deux\n  Pour estimer le nombre d\u0026rsquo;instructions, on divise n par 2 à chaque étape de recherce:\n si n=2048, on a:  éléments restants à visister après la 1ière étape: 2048 éléments restants à visister après la 2ième étape: 1024 éléments restants à visister après la 3ième étape: 512 éléments restants à visister après la 4ième étape: 256 éléments restants à visister après la 5ième étape: 128 éléments restants à visister après la 6ième étape: 64 éléments restants à visister après la 7ième étape: 32 éléments restants à visister après la 8ième étape: 16 éléments restants à visister après la 9ième étape: 8 éléments restants à visister après la 10ième étape: 4 éléments restants à visister après la 11ième étape: 2 éléments restants à visister après la 12ième étape: 1   on a terminé notre recherche en seulement 12 étapes (en terme d\u0026rsquo;informatique, c\u0026rsquo;est ridiculement petit)    Il s\u0026rsquo;agit de O(log(n)), le contraire d\u0026rsquo;une explosion exponentielle:\n      Les algorithmes O(log(n)) sont souvents les plus efficaces\n  Par exemple, voici des résultats comparant nos deux recherches:\n     Ce n\u0026rsquo;est pas une erreur si la ligne verte est presque invisible!  la recherche efficace est tellement rapide qu\u0026rsquo;on arrive à peine à la mesurer    Tri fusion: O(log(n)·n)   Est-ce qu\u0026rsquo;on peut appliquer l\u0026rsquo;idée de \u0026ldquo;diviser pour régner\u0026rdquo; au tri?\n  Oui, voici par exemple le tri fusion:\n  Tableau trier(Tableau entree):\n CRÉER un tableau resultat vide SI entree contient un seul élément ou moins:  copier entree dans resultat   SINON:  diviser le tableau entree en deux sous-tableaux égaux appeler trier() pour trier chaque sous-tableau appeler fusionner() pour fusionner les deux sous-tableaux copier le tableau fusionné dans resultat   retourner le tableau resultat     À chaque étape, on fait un nouvel appel à trier\n donc à chaque étape on divise entree en deux il va donc avoir log(n) étapes on va donc faire log(n) appels à fusionner()    Chaque appel à fusionner() demande au moins n instructions\n (chaque élément est manipulé une fois)    L\u0026rsquo;efficacité (complexité) de l\u0026rsquo;algorithme est donc O(log(n)·n)\n c\u0026rsquo;est à dire, on fait log(n) fois une étape qui demande n instructions    En terme d\u0026rsquo;efficacité, les algorithmes O(log(n)·n) sont presques aussi bon que O(n):\n     Par exemple, voici une comparaison entre le tri naïf et le tri fusion:     Encore une fois, ce n\u0026rsquo;est pas une erreur si la ligne verte est presque invisible!  en comparaison au tri naïf, le tri fusion est preque instantané    "},{"id":26,"href":"/listes/chainee_simple/","title":"Liste chaînée simple","section":"Comprendre les listes","content":"Liste chaînée simple  Une liste chaînée utilise des pointeurs (références), p.ex:      Chaque noeud ci-haut est un objet qui contient une valeur\n  Pour obtenir le prochain élément, on suit la référence (la flèche)\n  Inconvénient:\n il faut faire une boucle pour obtenir un élément de la liste    Avantages:\n l\u0026rsquo;insertion/retrait au début est efficace on ne consome pas d\u0026rsquo;espace mémoire en trop    Exemple: ajouts dans liste chaînée simple    liste\n// []       liste.add('a')\n// [a]       liste.add('b')\n// [a,b]       liste.add('c')\n// [a,b,c]      Liste chaînée simple en Java  Il faut une classe pour représenter un élément:  l\u0026rsquo;élément contient la valeur et un pointeur vers l\u0026rsquo;élément suivant    public class ElementChaineSimple\u0026lt;E\u0026gt; { private E valeur; private ElementChaineSimple\u0026lt;E\u0026gt; suivant = null; // [...] \tpublic void insererApres(E e) { ElementChaineSimple\u0026lt;E\u0026gt; nouveau = new ElementChaineSimple\u0026lt;E\u0026gt;(e); if(this.suivant != null) { nouveau.setSuivant(this.suivant); } this.suivant = nouveau; } // [...] }  Et une classe pour la liste:  on mémorise la tête et la taille    public class ListeJavaChaineeSimple\u0026lt;E extends Object\u0026gt; extends ListeJava\u0026lt;E\u0026gt; { private int taille = 0; private ElementChaineSimple\u0026lt;E\u0026gt; tete = new ElementChaineSimple\u0026lt;E\u0026gt;(); // [...] \tprivate ElementChaineSimple\u0026lt;E\u0026gt; atteindreElement(int position) { ElementChaineSimple\u0026lt;E\u0026gt; element = tete; for(int i = 0; i \u0026lt; position; i++) { if(element != null) { element = element.suivant(); } } return element; } @Override public void set(int position, E e) { ElementChaineSimple\u0026lt;E\u0026gt; element = atteindreElement(position); element.set(e); } // [...] }  Pour modifier un élément, il d\u0026rsquo;abord le trouver avec une boucle  "},{"id":27,"href":"/approche/","title":"Présentation de l'approche","section":"Cartes Java","content":"Présentation de l\u0026rsquo;approche  Utiliser des cartes à jouer pour enseigner la programmation Développer un outil de validation pour   visualiser comment les données sont structurées dans un programme Java\n  p.ex. le code suivant\nCarte[] tableauUn = new Carte[6]; Carte[] tableauDeux = new Carte[6]; int indiceCarteCourante = 1;   peut se visualiser de la façon suivante:\n    où:\n la première rangée de cartes est le tableauUn la deuxième rangée de cartes est le tableauDeux le point bleu indique la carte pointée par indiceCarteCourante      visualiser une procédure informatique (ou valider son implantation)\n  p.ex. voici une procédure naïve pour trier un tableau de cartes\n     à noter:\n les variables utilisées dans le code sont affichées en bas à droite      explorer un concept à l\u0026rsquo;écran (ou avec des vraies cartes à jouer)\n  p.ex. l\u0026rsquo;outil permet de trier les cartes à l\u0026rsquo;écran\n     à noter:\n Est-ce trié? devient true uniquement lorsque les cartes sont triées        Exemple de tri   Voici comment trier des cartes dans ce cours\n  Il faut placer les cartes dans l\u0026rsquo;ordre ♡ ♢ ♧ ♤, puis de la plus petite à la plus grande pour chaque sorte\n  non-trié:\n  trié par sorte:\n  trié par sorte et numéro:\n    Si on a uniquement des cartes de ♡, on peut trier selon le numéro\n  non-trié:\n  trié par sorte et numéro:\n    Si on a des cartes de ♡ et de ♧, on va trier par sorte, puis numéro\n  non-trié:\n  trié par sorte:\n  trié par sorte et numéro:\n    Et ainsi de suite, en respectant l\u0026rsquo;ordre ♡ ♢ ♧ ♤\n  En classe En classe, on peut expliquer les concepts de ce manuel avec des cartes géantes (et des aimants pour les maintenir au tableau).\ncrédit photo: Mikael Tardif\n"},{"id":28,"href":"/approche/cartes_a_jouer/","title":"Utilisation de cartes à jouer","section":"Présentation de l'approche","content":"Utilisation de cartes à jouer Exemple: déplacer/décaler On veut implanter les deux opérations suivantes dans un tableau de carte\n  déplacer une carte au début, en décalant vers la droite pour faire de la place:\n     déplacer une carte à la fin, en décalant vers la gauche pour faire de la place:\n      NOTE: on peut prendre n\u0026rsquo;importe quelles cartes pour illustrer ces opérations. Visualisation du code   On va visualiser le code suivant\nCarte[] cartes; int aDeplacer; int i; Carte memoireA; Carte memoireB;     Une carte blanche représente une case vide (valeur null) Procédure: déplacer au début Pour déplacer une carte au début, on va utiliser la procédure suivante\n    D\u0026rsquo;abord, mémoriser la carte à déplacer dans memoireA Ensuite, faire une boucle for pour visiter le bonnes cases du tableau  pour chaque case visitée  mémoriser la carte courante dans memoireB «monter» les cartes mémorisées:  «monter» memoireA dans le tableau «monter» memoireB dans memoireA          il y a une autre procédure qui utilise une seul case mémoire (Chut! Ne le dis pas, c\u0026rsquo;est une question bonus de l\u0026rsquo;atelier!)   Procédure: déplacer à la fin Pour déplacer une carte à la fin, on va utiliser la procédure suivante\n    D\u0026rsquo;abord, mémoriser la carte à déplacer dans memoireA Ensuite, faire une boucle for pour visiter les bonnes cases du tableau  pour chaque case visitée  déplacer la carte suivante à la case courante     Finalement, déplacer la carte mémorisée à la fin du tableau  "},{"id":29,"href":"/listes/chainee_double/","title":"Liste chaînée double","section":"Comprendre les listes","content":"Liste chaînée double Liste chaînée double  Dans une liste chaînée double, chaque élément pointe:  vers l\u0026rsquo;élément suivant: → vers l\u0026rsquo;élément précédent: ⇢        On peut donc accéder à la fin de la liste en reculant de 1 à partir de la tête\n ci-haut, si on recule de 1 à partir de a, on arrive à f    Inconvénients:\n plus difficile à implanter qu\u0026rsquo;une liste chaînée simple il faut quand même faire une boucle pour obtenir un élément de la liste    Avantages:\n on peut chercher un élément vers l\u0026rsquo;avant ou vers l\u0026rsquo;arrière l\u0026rsquo;insertion/retrait au début et à la fin est efficace on ne consome pas d\u0026rsquo;espace mémoire en trop    Exemple: ajouts dans liste chaînée double    liste\n// []       liste.add('a')\n// [a]       liste.add('b')\n// [a,b]       liste.add('c')\n// [a,b,c]       liste.add('d')\n// [a,b,c,d]      Liste chaînée double en Java  Notre classe pour l\u0026rsquo;élément contient cette fois-ci:  la valeur un pointeur vers l\u0026rsquo;élément suivant un pointeur vers l\u0026rsquo;élément précédent    public class ElementChaineDouble\u0026lt;E\u0026gt; { private E valeur; private ElementChaineDouble\u0026lt;E\u0026gt; suivant = this; private ElementChaineDouble\u0026lt;E\u0026gt; precedent = this; // [...] }  La classe pour la liste est similaire:  public class ListeJavaChaineeDouble\u0026lt;E extends Object\u0026gt; extends ListeJava\u0026lt;E\u0026gt; { private int taille = 0; private ElementChaineDouble\u0026lt;E\u0026gt; tete = null; // [...]  }   Pour modifier un élément, on fait une boucle:\n soit en cherchant vers l\u0026rsquo;avant  (lorsque la position est proche du début)   soit en cherchant vers l\u0026rsquo;arrière  (lorsque la position est proche de la fin)      Pour insérer, on peut soit:\n insérer après un élément insérer avant un élément    P.ex. insérer à la fin de la liste équivaut à:\n insérer avant la tête!    Efficacité simple Vs double  Pour ajouter à la fin:     Pour retirer à la fin:     Pour insérer au début:     Pour retirer au début:     Pour modifier au milieu:    "},{"id":30,"href":"/modelisation/","title":"Modéliser des données","section":"Cartes Java","content":"Modéliser des données "},{"id":31,"href":"/modelisation/json/","title":"Modéliser en JSON","section":"Modéliser des données","content":"Modéliser en JSON "},{"id":32,"href":"/modelisation/java/","title":"Modéliser en Java","section":"Modéliser des données","content":"Modéliser en Java "},{"id":33,"href":"/efficacite/espace/","title":"Efficacité en espace","section":"Qu'est-ce que l'efficacité?","content":"Efficacité en espace "},{"id":34,"href":"/efficacite/","title":"Qu'est-ce que l'efficacité?","section":"Cartes Java","content":"Qu\u0026rsquo;est-ce que l\u0026rsquo;efficacité? "},{"id":35,"href":"/listes/","title":"Comprendre les listes","section":"Cartes Java","content":"Comprendre les listes "},{"id":36,"href":"/arbres/","title":"Comprendre les arbres","section":"Cartes Java","content":"Comprendre les arbres "},{"id":37,"href":"/arbres/generique/","title":"Arbre générique","section":"Comprendre les arbres","content":"Arbre générique "},{"id":38,"href":"/arbres/binaire/","title":"Arbre binaire","section":"Comprendre les arbres","content":"Arbre binaire "},{"id":39,"href":"/mappage/","title":"Comprendre les mappages","section":"Cartes Java","content":"Comprendre les mappages "},{"id":40,"href":"/conclusion/","title":"Conclusion","section":"Cartes Java","content":"Conclusion "},{"id":41,"href":"/grand-o/","title":"Annexe 1: sémantique de la notation grand O","section":"Cartes Java","content":"Annexe 1: sémantique de la notation grand O "},{"id":42,"href":"/modifier/","title":"Annexe 2: comment copier et modifier ce manuel","section":"Cartes Java","content":"Comment modifier ce manuel Obtenir les sources Le source est ici: https://github.com/cartesjava/cartesjava.github.io\nSuggérer une modification   Cliquer sur Suggérer une modification\n  Se connecter à GitHub\n  Modifier le source de la page et faire un commit pour envoyer la suggestion au propriétaire du dépôt\n  "},{"id":43,"href":"/mappage/arbre/","title":"Mappage avec arbre","section":"Comprendre les mappages","content":"Mappage avec arbre   On peut implanter un map avec un arbre binaire de recherche\n  Il faut que chaque noeud soit une paire\n  Considérer le map {0:'w', 1:'h', 2:'t', 3:'d', 4:'a', 5:'z', 6:'h'}\n  Voici l\u0026rsquo;arbre avec uniquement les clés:\n   RAPPEL:  chaque noeud a au plus deux enfants à gauche il y a toujours des valeurs plus petites à droite il y a toujours des valeurs plus grandes      Pour faire un map, il faut mémoriser des paires clé/valeur\n mais quand même chercher avec la clé       Donc, on va:  trouver un noeud en cherchant la clé une fois le noeud trouvé, on va obtenir ou modifier la valeur    Problème d\u0026rsquo;efficacité   Pour que la recherche soit efficace, il faut que l\u0026rsquo;arbre soit équilibré\n c-à-d l\u0026rsquo;abre doit être aussi gros à gauche qu\u0026rsquo;à droite comme ça on peut utiliser l\u0026rsquo;approche «diviser pour régner»  c-à-d diviser la recherche en deux à chaque étape      Par exemple, l\u0026rsquo;arbre suivant est valide, mais ne permet pas de recherche efficace:\n     Dans le cas ci-haut, la recherche n\u0026rsquo;est pas plus effiace que pour une liste chaînée  S\u0026rsquo;assurer d\u0026rsquo;avoir des arbres équilibrés   Selon l\u0026rsquo;ordre d\u0026rsquo;insertion, l\u0026rsquo;arbre sera équilibré ou non.\n  Si on insère 3,1,5,0,2,4,6, l\u0026rsquo;arbre est équilibré:\n     arbre.inserer(3)       arbre.inserer(1)       arbre.inserer(5)       arbre.inserer(0)       arbre.inserer(2)       arbre.inserer(4)       arbre.inserer(6)       Mais si on insère 6,5,4,3,2,1,0, l\u0026rsquo;arbre est complétement déséquilibré     arbre.inserer(6)       arbre.inserer(5)       arbre.inserer(4)       arbre.inserer(3)       arbre.inserer(2)       arbre.inserer(1)       arbre.inserer(0)        Évidement, on a pas de contrôle sur l\u0026rsquo;ordre d\u0026rsquo;insertion des éléments\n  La solution est de ré-équilibrer l\u0026rsquo;arbre après chaque insertion\n     arbre.inserer(3)       arbre.inserer(1)       arbre.inserer(0)       arbre.equilibrer()        L\u0026rsquo;opération pour équilibrer l\u0026rsquo;arbre est appelée une rotation\n p.ex. pour l\u0026rsquo;arbre ci-haut:  le 3 tourne vers la droite et descend le 1 tourne vers la droite et monte le 0 tourne vers la droite et suit le 1      Si on équilibre à chaque insertion, ce n\u0026rsquo;est pas coûteux en temps\n c\u0026rsquo;est par contre délicat à coder    Performance en pratique   En général, un peu moins bon qu\u0026rsquo;une table de hachage\n  Mais prend moins d\u0026rsquo;espace mémoire\n     RAPPEL: l\u0026rsquo;efficacité de la table de hachage peut varier selon la taille de la table et la fonction de hachage  "},{"id":44,"href":"/modelisation/recursivite/donnees/","title":"Types récursifs","section":"Récursivité","content":"Types récursifs Arbre   Un arbre est une structure avec une racine et des branches:\n   NOTE: l\u0026rsquo;arbre est typiquement dessiné avec la racine en haut    Chaque cercle ci-haut est appelé un noeud\n  Chaque noeud peut avoir des enfants (indiqués par les flèches)\n  Chaque noeud a exactement un parent (sauf la racine qui n\u0026rsquo;a aucun parent)\n  Arbre binaire de recherche   C\u0026rsquo;est un type d\u0026rsquo;arbre très utilisé en informatique:\n    Chaque noeud contient un Comparable (p.ex. un int)\n  Chaque noeud a au plus deux enfants\n  L\u0026rsquo;enfant à gauche est toujours plus petit que le parent (et grand-parent, etc.)\n p.ex.: 0 \u0026lt; 1 et 4\u0026lt;5    L\u0026rsquo;enfant à droite est toujours plus grand que le parent (et grand-parent, etc.)\n p.ex.: 5\u0026gt;3 et 2\u0026gt;1    Arbre binaire en Java   Il suffit de représenter un Noeud\n    La définition de Noeud est récursive:\n Qu\u0026rsquo;est-ce qu\u0026rsquo;un Noeud?  quelque chose qui contient deux noeuds!  enfantGauche() et enfantDroit()        Par exemple, pour représenter l\u0026rsquo;arbre ci-haut:\n  Noeud racine = new MonNoeud(3); Noeud gauche = new MonNoeud(1); Noeud droite = new MonNoeud(5); Noeud gaucheGauche = new MonNoeud(0); Noeud gaucheDroite= new MonNoeud(2); Noeud droiteGauche = new MonNoeud(4); Noeud droiteDroite= new MonNoeud(6); racine.setEnfantGauche(gauche); racine.setEnfantDroit(droite); gauche.setEnfantGauche(gaucheGauche); gauche.setEnfantDroit(gaucheDroite); droite.setEnfantGauche(droiteGauche); droite.setEnfantDroit(droiteDroite); "}]