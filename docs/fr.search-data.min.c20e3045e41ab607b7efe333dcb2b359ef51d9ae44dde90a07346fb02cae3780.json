[{"id":0,"href":"/annexes/annexe_bilans/bilan_juin_2022/","title":"Bilan juin 2022","section":"Annexe 6: bilans","content":"Bilan juin 2022 #  Projets étudiants #    De gauche à droite :\n Zein-El-Abdin Hazimeh Mathieu Bergeron Marlond Augustin Adrien Joséphine-Olivier       Crédit photo : Marlond Augustin Les participants ont signé un formulaire de consentement concernant la reproduction des trois photos ci-haut.  Fonctionnalités implantées #  Interface de base #    NOTES :\n Des améliorations à l\u0026rsquo;interface sont à venir (projet de Zein Hazimeh)  Validation interactive du code #  Comparaison du code étudiant (erreur à l\u0026rsquo;étape 22) :\n  Avec la solution (étape 22) :\n  Animation d\u0026rsquo;un tri naïf #    Réalisation à l\u0026rsquo;écran d\u0026rsquo;un tri naïf #    Animation de l\u0026rsquo;opération de retrait dans une liste tableau #    Choix entre différents exemples #    Prochaine étape : intégration des outils au cours 3C6 #    Évaluations formatives avec les cartes\n entrevue de 5min avec l\u0026rsquo;enseignant l\u0026rsquo;étudiant.e doit démontrer sa compréhension de la procédure vue en théorie    Ateliers à réaliser avec l\u0026rsquo;outil de validation codelescartes.ca\n introduction liste par tableau (projet de Marlond Augustin) tri fusion (projet d\u0026rsquo;Adrien Joséphine-Olivier) tri naïf liste chaînée simple et double mappage par arbre binaire    Voir la page du cours 3C6\n"},{"id":1,"href":"/annexes/annexe_bilans/bilan_octobre_2022/","title":"Bilan octobre 2022","section":"Annexe 6: bilans","content":"Bilan octobre 2022 #  Avancement actuel #  Brouillons sur codelescartes.ca\n Présentation de l\u0026rsquo;approche Comment modifier ce manuel  Matériel de mon cours 3C6 développé pour ce projet et qu\u0026rsquo;il reste à inclure dans le manuel codelescartes.ca\n Procédure pour déplacer/décaler des cartes Modéliser des cartes  graphe d\u0026rsquo;objets   Récursivité  modélisation de la séquence de Fibonacci    Matériel qui existait déjà pour mon cours 3C6 et qu\u0026rsquo;il reste à inclure dans le manuel codelescartes.ca\n Structures de données en Java Structures de données en JSON  Ressources trouvées par Valérie Jacques #  Les ressources ci-bas pourront servir d\u0026rsquo;inspiration pour le manuel :\nAlgorithms and Data Structures With Application to Graphics and Geometry(2011) de Jurg Nievergelt et Klaus Hinrichs ;\u0026nbsp;Data Structures : {fundamental tools}(revisé en 2020) de Alfred V. Aho, Jeffrey D. Ullman et al. [Wikibooks] ;\u0026nbsp;Introduction to Programming Using Java (8 éd., 2022) de David J. Eck ;\u0026nbsp;Java, Java, Java : Object-Oriented Problem Solving (2017) de Ralph Morelli et Ralph Walde ;\u0026nbsp;Programming Fundamentals : A Modular Structured Approach (2e éd., 2018) de Kenneth Leroy Busbee et Dave Braunschweig ;\u0026nbsp;Think Java : How to Think Like a Computer Scientist (2e éd., 2020) de Chris Mayfield et Allen Downey.\u0026nbsp; Pour l\u0026rsquo;instant, il n\u0026rsquo;est pas prévu de traduire des sections des ressources ci-haut dans le but des intégrer au présent manuel.\nPour finaliser le projet #    L\u0026rsquo;objectif pour février 2023 est de rédiger 25% du manuel initialement prévu, soit environs 50 pages\n  L\u0026rsquo;objectif demeure réaliste\n le matériel créé pour ce projet compte déjà environs 20 pages le matériel que j\u0026rsquo;ai déjà compte pour un autre 20 pages    À noter que cette portion du manuel risque d\u0026rsquo;être partiellement réécrite puisque l\u0026rsquo;approche a encore besoin d\u0026rsquo;être peaufinée\n  Impressions et réflexions #  Ce qui fonctionne bien #    C\u0026rsquo;est très agréable d\u0026rsquo;utiliser les cartes surdimensionnées pour expliquer une procédure au tableau blanc :\nCrédit photo : Mikael Tardif\n  C\u0026rsquo;est aussi très agréable de faire des séances de théorie 100% au tableau blanc, sans utiliser le projecteur\n  Les étudiant·e·s semblent apprécier l\u0026rsquo;utilisation de cartes à jouer et adhérent bien à l\u0026rsquo;idée de faire des entrevues formatives\n (durant l\u0026rsquo;entrevue formative, l\u0026rsquo;étudiant.e démontre sa compréhension de la théorie avec des cartes ou en dessinant un schéma sur papier)    Les étudiant·e·s semblent beaucoup apprécier l\u0026rsquo;outil de validation, en particulier le fait que l\u0026rsquo;outil génère des visualisations à partir de leur code. P.ex.\ncartes = new MaCarte[] {new MaCarte(1, Sorte.CARREAU),  null,  new MaCarte(1, Sorte.COEUR)};  memoireA = null; memoireB = new MaCarte(1, Sorte.TREFLE); i = 1; aDeplacer = 2;    Ce qui reste à peaufiner #    Tout! L\u0026rsquo;approche a besoin de « vivre un peu ». P.ex.\n plusieurs étudiant·e·s ont pris du temps à réaliser que l\u0026rsquo;outil de validation générait des visualisations à partir de leur code. Il faudra trouver des façons de présenter cet aspect plus directement (d\u0026rsquo;autant plus que c\u0026rsquo;est un aspect très apprécié une fois découvert!). les étudiant·e·s ont trouvé facile de trier des cartes, mais plus difficile de traduire en code la procédure. Je pense que je devrai fournir plus d\u0026rsquo;exemples plus rapidement afin de pratiquer cette « traduction ».    Malheureusement, pour l\u0026rsquo;instant, créer un nouvel exemple de visualisation est difficile et long. Je dois écrire beaucoup de code pour créer les visualisations et ces dernières doivent quand même être capturées à la main avec un outil de capture d\u0026rsquo;écran. Certains graphes d\u0026rsquo;objets doivent aussi être retravailler à la main, p.ex. ci-bas pour y inclure la variable nouvelleTete\n  Trois « intuitions de programmeur » à mieux enseigner #    Construire et imaginer un graphe d\u0026rsquo;objets\n  Utiliser une variable de type « curseur » pour pointer sur différents objets d\u0026rsquo;un graphe d\u0026rsquo;objets durant l\u0026rsquo;exécution du programme\n  Utiliser des appels récursifs pour construire un graphe d\u0026rsquo;objet\n  Recommandations pour le suivi de projet #  "},{"id":2,"href":"/listes/naive/","title":"Liste naïve","section":"Comprendre les listes","content":"Section 4.1: Liste naïve #  "},{"id":3,"href":"/listes/tableau/","title":"Liste par tableau","section":"Comprendre les listes","content":"Section 4.2: Liste par tableau #  "},{"id":4,"href":"/preface/","title":"Préface","section":"Code les cartes!","content":"Préface #   Ce manuel a été développé entre avril 2022 et février 2023 suite à l\u0026rsquo;obtention d\u0026rsquo;une subvention de la fabriqueREL.\n   Version  22 février 2023\n   Dépôt source   https://github.com/cartesjava/cartesjava.github.io\n   Auteur Mathieu Bergeron    Remerciements  Un grand merci à la fabriqueREL d\u0026rsquo;avoir supporté la création de ce manuel.\n   Participation étudiante  Grâce au financement de la fabriqueREL, trois étudiants ont contribué au développement du logiciel qui accompagne ce manuel, soit : Adrien Joséphine-Olivier, Marlond Augustin et Zein-El-Abdin Hazimeh\n   Mise en page  La mise en page repose sur le thème hugo-book, modifié par Mathieu Bergeron pour les besoins de ce manuel (p. ex. ajout de la numération des sections)\n   Suivi de projet  De la fabriqueREL : Claude Potvin (conseiller pédagogique) et Marianne Dubé (coordonatrice). Du Collège Montmorency : Philippe Lavigueur (conseiller pédagogique) et Valérie Jacques (spécialiste en moyens et techniques d\u0026rsquo;enseignement).\n   Comité de relecture  Enseignant·e·s en informatique au Collège Montmorency : Soumaya Medini, Axel Seguin, Nicolas Leduc, Frédéric Édoukou, Simon Deschênes et Sylvain Labranche.\n   Pour citer cet ouvrage  Bergeron, M. (2023). Code les cartes! Apprendre à programmer efficacement avec des cartes à jouer. Collège Montmorency. CC BY-SA\n    Sauf indications contraires, le contenu de ce manuel électronique est disponible en vertu des conditions de la Licence Creative Commons Attribution - Partage dans les mêmes conditions 4.0 International.   Vous êtes autorisé à:\nPartager — Copier, distribuer et communiquer le matériel par tous moyens et sous tous formats.\n  Adapter — Remixer, transformer et créer à partir du matériel pour toute utilisation, y compris commerciale.\n      Selon les conditions suivantes:\nPaternité — Vous devez citer le nom de l’auteur original.\n  Mêmes conditions — Si vous remixez, transformez, ou créez à partir du matériel composant l\u0026rsquo;Oeuvre originale, vous devez diffuser l\u0026rsquo;Oeuvre modifiée avec la même licence.\n            "},{"id":5,"href":"/procedures/windows/eclipse/","title":"Procédure: installer Eclipse","section":"Windows","content":"Procédure: installer Eclipse #   Rappel\u0026nbsp;: ne pas effectuer cette étape sur un Windows du Collège     Recomandé : désinstaller toute ancienne version d\u0026rsquo;Eclipse\n  Installer Eclipse (version 2022-06 ou plus récent)\n Visiter https://www.eclipse.org/downloads/ Télécharger en cliquant sur Download x86_64 Exécuter eclipse-inst-win64.exe Installer Eclipse IDE for Java Developers avec les options par défaut    %!s().1 Configurer Eclipse #   --   Je démarre Eclipse\n Je choisi mon WORKSPACE, p.ex.  Z:\\eclipse-workspace (Windows du Collège) C:\\Users\\PRENOM_NOM\\eclipse-workspace (Mon Windows)      Je m\u0026rsquo;assure que Eclipse utilise le JDK 11\n  Window =\u0026gt; Preferences\n  Java =\u0026gt; Installed JREs\n    Idéallement, Eclipse utilise uniquement le JDK 11\n  Si j\u0026rsquo;en ai pas besoin, je fait Remove sur tous les JDK sauf 11\n  Si le JDK 11 n\u0026rsquo;est pas là, je l\u0026rsquo;ajoute :\n Add =\u0026gt; Standard VM =\u0026gt; Next Sélectionner le répertoire racine du JDK, p.ex :  C:\\Program Files\\Java\\jdk-11.XXX   Finish Apply and Close    Je m\u0026rsquo;assure que le JDK 11 est le défaut (en gras)\n    "},{"id":6,"href":"/procedures/windows/git/","title":"Procédure: installer Git","section":"Windows","content":"Procédure: installer Git #   Rappel\u0026nbsp;: ne pas effectuer cette étape sur un Windows du Collège    Visiter https://git-scm.com/download/win Télécharger et et exécuter Git-2.37.2.2-64-bit.exe Installer avec les options par défaut, sauf :  Recommandé : choisir nano comme éditeur plutôt que vim :       "},{"id":7,"href":"/procedures/windows/jdk11/","title":"Procédure: installer le JDK 11","section":"Windows","content":"Procédure: installer le JDK 11 #    Si ce n\u0026rsquo;est pas déjà fait, créer un compte Oracle : https://profile.oracle.com/myprofile/account/create-account.jspx\n  Visiter https://www.oracle.com/java/technologies/javase/jdk11-archive-downloads.html\n  Télécharger la version Windows x64 Installer\n jdk-11.0.16_windows-x64_bin.exe    Accepter la licence et je clique sur Download\n  Exécuter jdk-11.0.16_windows-x64_bin.exe\n  Installer avec les options par défaut\n  "},{"id":8,"href":"/procedures/gitlab/inscription/","title":"Procédure: s'inscrire à GitLab","section":"Gitlab","content":"Procédure: s\u0026rsquo;inscrire à GitLab #    Visiter https://gitlab.com\n Cliquer sur Register    Remplir le formulaire\n  Cliquer sur Je ne suis pas un robot\n  Cliquer sur Register\n    Attendre le courriel de confirmation\n Cliquer sur le lien dans le courriel pour confirmer l\u0026rsquo;inscription    "},{"id":9,"href":"/intro/","title":"Introduction","section":"Code les cartes!","content":"Introduction #   Dans ce manuel, nous développons une approche pour enseigner la programmation avec des cartes à jouer. Les étudiant·e·s seront invité·es à réaliser une procédure informatique avec des cartes, avant de programmer cette procédure en Java et, finalement, de valider leur code à l\u0026rsquo;aide d\u0026rsquo;un logiciel créé spécifiquement pour accompagner ce manuel.\nNous utilisons ensuite cette approche pour expliquer les notions d\u0026rsquo;efficacité (complexité des algorithmes) et de structure de données (en particulier les listes, les arbres et les mappages).\n À qui s\u0026rsquo;adresse ce manuel? #  L\u0026rsquo;approche développée dans ce manuel cible des étudiant·e·s ayant déjà suivi un cours d\u0026rsquo;introduction à la programmation, mais qui pourraient éprouver certaines difficultés à :\n imaginer les étapes exactes d\u0026rsquo;une procédure informatique imaginer comment les données du programme sont organisées en mémoire réfléchir à l’efficacité du programme distinguer les notions d\u0026rsquo;interface (ce que le programme doit faire) et d\u0026rsquo;implantation (comment le programme le fait)  Comme les exemples de code sont en Java, il est préférable d\u0026rsquo;avoir une certaine familiarité avec ce langage (ou avec un langage similaire comme C#).\nPourquoi utiliser des cartes à jouer? #  L\u0026rsquo;idée est d\u0026rsquo;utiliser un médium physique pour expliquer des notions de programmation, afin de supporter d\u0026rsquo;autres styles d\u0026rsquo;apprentissage (visuel, kinesthésique) et d\u0026rsquo;encourager les étudiant·e·s à bien comprendre le déroulement d\u0026rsquo;une procédure informatique avant même de commencer à la programmer.\nLes cartes à jouer sont avantageuses parce qu\u0026rsquo;elles sont accessibles et peu dispendieuses. Par exemple, on peut facilement se procurer des cartes surdimensionnées qui permettront d\u0026rsquo;expliquer des notions informatiques devant la classe, et ce, de façon très visuelle.\n    \u0026nbsp;  Crédit photo\u0026nbsp;: Mikael Tardif    Un autre avantage est qu\u0026rsquo;on peut vérifier la compréhension des étudiant·e·s dès la période de théorie, sans même utiliser d\u0026rsquo;ordinateurs. Dans l\u0026rsquo;exemple ci-bas, on spécifie visuellement une opération à effectuer sur une liste de cartes. Cette opération consiste à déplacer une carte (identifiée par un marqueur) au début de liste, ce qui nécessite en retour de décaler certaines cartes vers la droite.\n   \u0026nbsp; Énoncé visuel  Manipulations sur la table     Opération à réaliser           On peut demander aux étudiant·e·s d\u0026rsquo;effectuer cette opération avec des vraies cartes, permettant ainsi à l\u0026rsquo;enseignant·e de vérifier que l\u0026rsquo;énoncé a bien été compris (c.-à-d. l\u0026rsquo;interface, ou ce que le programme doit faire).\nOn peut ensuite présenter une procédure afin de réaliser l\u0026rsquo;opération (c.-à-d. l\u0026rsquo;implantation, ou comment le programme doit le faire). Dans l\u0026rsquo;exemple ci-bas, on utilise une procédure qui visite la liste du début vers la fin (ce qui correspond au genre de boucle que les étudiant·e·s ont probablement déjà appris). Encore une fois, les étudiant·e·s pourront réaliser la procédure sur la table, avec de vraies cartes, et ainsi s\u0026rsquo;assurer de comprendre ce qu\u0026rsquo;il faut programmer avant même d\u0026rsquo;écrire les premières lignes de code.\n   \u0026nbsp; Énoncé visuel  Manipulations sur la table    Procédure à suivre           Finalement, à noter les animations ci-haut sont tirées de l\u0026rsquo;outil de validation qui accompagne ce manuel. Grace à cet outil, les étudiant·e·s peuvent valider leur programme, en particulier :\n visualiser les étapes d\u0026rsquo;exécution de leur code vérifier que leur code arrive au bon résultat  Expliquer l\u0026rsquo;efficacité des algorithmes avec des cartes #  Une fois les étudiant·e·s habitué·es à réaliser des procédures avec les cartes à jouer, on peut passer à expliquer la notion d\u0026rsquo;efficacité (complexité des algorithmes), c\u0026rsquo;est-à-dire comment différentes procédures informatiques peuvent accomplir la même opération (c.-à-d. arriver au même résultat), tout en nécessitant un nombre d\u0026rsquo;étapes significativement différent.\nOn distingue ainsi entre les procédures naïves (souvent plus faciles à comprendre, mais peu efficaces) et les procédures efficaces (souvent plus difficiles à comprendre, mais plus rapides à réaliser). Par exemple, pour une liste de 10 cartes, ordonner les cartes avec une procédure naïve de tri nécessitera une centaine étapes, alors qu\u0026rsquo;une procédure efficace de tri arrivera au même résultat en une trentaine d\u0026rsquo;étapes.\nEn effectuant diverses procédures sur la table, avec des vraies cartes à jouer, les étudiant·e·s gagnent une compréhension très intuitive de la notion d\u0026rsquo;efficacité informatique: les procédures naïves se révèlent rapidement comme longues et ennuyantes à réaliser!\nExpliquer les structures de données avec des cartes #  Finalement, on peut aussi se servir de cartes à jouer afin de visualiser l\u0026rsquo;organisation des données dans un programme informatique, ce qui est particulièrement intéressant afin d\u0026rsquo;expliquer comment une structure de données (par exemple une liste) peut être implantée de différentes façons dans un langage de programmation.\nEn s\u0026rsquo;appuyant sur la notion d\u0026rsquo;efficacité, on peut aussi expliquer les avantages et inconvénients de ces différentes implantations. Par exemple, une liste implantée par références (liste chaînée) sera moins efficace qu\u0026rsquo;une liste implantée par tableau au moment de visiter une valeur mémorisée au milieu de la liste. Par contre, la liste par référence utilisera moins d\u0026rsquo;espace en mémoire.\nOn peut visualiser ce dernier point assez concrètement avec des cartes à jouer, surtout si on utilise des cartes blanches (ou le verso de cartes) pour visualiser l\u0026rsquo;espace mémoire vide (c.-à-d. l\u0026rsquo;espace occupé par le programme, mais dans lequel le programme n\u0026rsquo;a pas encore mémorisé de valeur). Une procédure utilisant beaucoup d\u0026rsquo;espace mémoire va tout simplement nécessiter plus d\u0026rsquo;espace sur la table!\nPlan du manuel #     Chapitre 1   Nous présentons l\u0026rsquo;approche de façon plus détaillée, y compris en survolant les fonctionnalités de l\u0026rsquo;outil de validation qui accompagne ce manuel. Nous discutons des langages et notations que nous utilisons (Java, JSON, diagrammes de classe et graphe d\u0026rsquo;objets). Nous donnons des exemples du type de visualisation avec des cartes à jouer que notre approche supporte.\n    Chapitre 2   Nous donnons des exemples de modélisation de données qui cadrent bien avec l'approche que nous développons. En particulier, nous considérons les notions d'objet, de tableau d'objets et de graphe d'objets. À travers ce chapitre, nous discutons aussi des limitations de la visualisation avec des cartes à jouer.     Chapitre 3 Chapitre 3 --   Nous présentons la notion d'efficacité de façon intuitive, sans entrer dans les détails mathématiques (ce que nous réservons pour l'Annexe 1). Nous distinguons les notions de performance (une mesure de temps d'exécution) et d'efficacité (une mesure du nombre d'étapes qu'une procédure nécessite). Nous différencions aussi l'efficacité en termes de temps (nombre d'étapes) et d'espace mémoire et donnons quelques exemples du compromis bien connu entre temps et mémoire (on peut souvent réduire le nombre d'étapes à exécuter si on accepte d'utiliser plus d'espace mémoire).     Chapitre 4 Chapitre 4--   Nous présentons notre première structure de données\u0026nbsp;: la liste. Nous présentons l'interface d'une liste (c.-à-d. quelles opérations une liste doit accomplir), ainsi que quatre implantations différentes\u0026nbsp;: liste naïve, liste par tableau, liste chaînée simple et liste chaînée double. Présenter d'abord une implantation naïve nous permet à la fois de bien expliquer l'interface de la liste, mais aussi d'obtenir un point de comparaison utile pour réfléchir à l'efficacité des différents types de liste.     Chapitre 5 Chapitre 5--   Nous présentons la notion d'arbre, une structure de donnée omniprésente en informatique. Nous implanterons un arbre générique, ainsi qu'un arbre binaire de recherche.     Chapitre 6 Chapitre 6--   Nous présentons notre deuxième structure de données\u0026nbsp;: le mappage. Nous présentons l'interface d'un mappage, que trois implantations différentes\u0026nbsp;: mappage naïf, mappage par hachage et mappage par arbre. Encore une fois, présenter d'abord une implantation naïve permet de bien expliquer l'interface et d'obtenir un point de comparaison pour réfléchir à l'efficacité des différents types de mappage.     Conclusion Conclusion--   En guise de conclusion, nous donnons nos impressions sur l'utilisation de notre approche en classe et discutons d'améliorations et extensions possibles à l'approche.     Bibliographie   Références bibliographiques.    Annexes #    Annexe 1   La notation grand O est présentée de façon plus mathématique.    Annexe 2   Nous expliquons comment accéder aux exemples utilisés dans ce manuel.    Annexe 3   Nous expliquons comment ajouter un nouvel exemple à l'outil de validation.    Annexe 4   Nous expliquons comment adapter ce manuel, ou encore comment suggérer une modification à la version actuelle.    Annexe 5   Nous présentons quatre exemples d'atelier qui utilisent l'approche développée dans ce manuel.    Annexe 6   Cet annexe archive les bilans rédigés lors du développement de ce manuel (avril 2022 à février 2023).    "},{"id":10,"href":"/mappages/naif/","title":"Mappage naïf","section":"Comprendre les mappages","content":"Section 6.1: Mappage naïf #  "},{"id":11,"href":"/mappages/hachage/","title":"Mappage par hachage","section":"Comprendre les mappages","content":"Section 6.2: Mappage par hachage #  "},{"id":12,"href":"/modelisation/objets/","title":"Objets","section":"Modélisation des données et limitations de l'approche","content":"Section 2.1: Objets #  L\u0026rsquo;unité de base d\u0026rsquo;un modélisation orientée-objet est l\u0026rsquo;objet. Nous donnons ici quelques exemples de modélisations, tout en discutant de la possibilité de visualiser ces données avec des cartes à jouer.\n2.1.1 Modéliser une carte #  Une carte est modélisée par la classe suivante :\nL\u0026rsquo;attribut de type Sorte correspond à une énumération :\npublic enum Sorte {  COEUR, CARREAU, TREFLE, PIQUE; } Voici quelques exemples de cartes.\n     {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 9,  \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34; }         {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 3,  \u0026#34;sorte\u0026#34;: \u0026#34;TREFLE\u0026#34; }         {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 58,  \u0026#34;sorte\u0026#34;: \u0026#34;PIQUE\u0026#34; }      À noter qu\u0026rsquo;on peut représenter des cartes qui n\u0026rsquo;existent pas dans un paquet de carte ordinaire (comme le 58 de pique ci-haut). Par contre, comme notre objectif est que chaque procédure visualisée avec des cartes puisse être aisément réalisée sur une table, avec de vraies cartes à jouer, il est préférable de s\u0026rsquo;en tenir aux cartes suivantes :\n 2-10 de coeur 2-10 de carreau 2-10 de trèfle 2-10 de pique  Idéalement, les exemples illustrés par des cartes devraient donc se limiter à 32 objets.\n2.1.2 Modéliser un film et un personnage #  On peut évidemment modéliser autre chose que des cartes. Voici par exemple une classe représentant un film.\nVoici des objets représentant certains films en particulier.\n     {  \u0026#34;_C\u0026#34;: \u0026#34;Film\u0026#34;,  \u0026#34;titre\u0026#34;: \u0026#34;Dr. No\u0026#34;,  \u0026#34;annee\u0026#34;: 1962 }       {  \u0026#34;_C\u0026#34;: \u0026#34;Film\u0026#34;,  \u0026#34;titre\u0026#34;: \u0026#34;Bons Baisers de Russie\u0026#34;,  \u0026#34;annee\u0026#34;: 1963 }   Voici une classe représentant un personnage.\n Finalement, voici des objets représentant des personnages en particulier.\n     {  \u0026#34;_C\u0026#34;: \u0026#34;Personnage\u0026#34;,  \u0026#34;personnagePrincipal\u0026#34;: true,  \u0026#34;nom\u0026#34;: \u0026#34;James Bond\u0026#34;       {  \u0026#34;_C\u0026#34;: \u0026#34;Personnage\u0026#34;,  \u0026#34;nom\u0026#34;: \u0026#34;Docteur No\u0026#34;,  \u0026#34;personnagePrincipal\u0026#34;: false }       {  \u0026#34;_C\u0026#34;: \u0026#34;Personnage\u0026#34;,  \u0026#34;nom\u0026#34;: \u0026#34;Rosa Klebb\u0026#34;,  \u0026#34;personnagePrincipal\u0026#34;: false }    "},{"id":13,"href":"/approche/outil/","title":"Outil de validation","section":"Présentation de l'approche","content":"Section 1.1: Outil de validation #  1.1.1 Démarrer l\u0026rsquo;outil #  Pour utiliser l\u0026rsquo;outil de validation, il faut l\u0026rsquo;intégrer à un projet Java. Pour l\u0026rsquo;exemple présenté en Introduction, on débutera avec le code suivant :\npublic class MonTableau extends Tableau {   public void deplacerDecaler() {  // implanter la procédure ici  } } public class Procedure extends ProcedureDecaler\u0026lt;MonTableau\u0026gt; {   public static void main(String[] args) {  NtroClientFx.launch(args);  }   protected Class\u0026lt;MonTableau\u0026gt; classeMonTableau() {  return MonTableau.class;  } } À l\u0026rsquo;exception de la méthode deplacerDelacer, qui doit être complétée, les étudiant·e·s n\u0026rsquo;ont pas à comprendre ce code, qui ne sert qu\u0026rsquo;à intégrer l\u0026rsquo;outil de validation à leur projet Java. Pour plus de détails, voir les exemples d\u0026rsquo;ateliers à l\u0026rsquo;Annexe 4.\nExécuter le projet Java va démarrer l\u0026rsquo;outil:\n  À noter que bien que le manuel fait référence à un outil de validation (au singulier), il faut en réalité intégrer une version différente de l\u0026rsquo;outil de validation pour chaque procédure à valider. Chaque version définit aussi sa propre visualisation des données avec des cartes à jouer. Voir l\u0026rsquo;Annexe 2 pour plus de détails.\n1.1.2 Utiliser l\u0026rsquo;outil #  Voici les affichages principaux de l\u0026rsquo;outil de validation.\n   Le panneau principal (1) affiche des cartes à jouer Le panneau des cas de tests (2) permet de  sélectionner un nouveau cas de test visualiser les résultats de la validation   Le panneau de navigation (3) permet d\u0026rsquo;avancer et/ou reculer dans la séquence d\u0026rsquo;exécution Le panneau des variables (4) visualise les diverses valeurs pour l\u0026rsquo;état courant de l\u0026rsquo;exécution  1.1.2.1 Visualisation avec des cartes à jouer #  Des cartes à jouer animées permettent de visualiser l\u0026rsquo;exécution d\u0026rsquo;une procédure informatique.\n      L\u0026rsquo;exécution de la procédure se déroule en un certain nombre d\u0026rsquo;étapes. La transition d\u0026rsquo;une étape à l\u0026rsquo;autre est illustrée par une animation où, par exemple, une carte peut changer de position.\nÀ noter que la visualisation est différente pour chaque procédure, tel qu\u0026rsquo;expliqué à la Section 1.3. À noter aussi qu\u0026rsquo;utiliser des cartes à jouer s\u0026rsquo;accompagne de certaines limitations, telles que discutées au Chapitre 2.\n1.1.2.2 Sélection de différents cas de test #  Au démarrage, l\u0026rsquo;outil charge plusieurs cas de tests. La première étape d\u0026rsquo;un cas de test contient des valeurs pour chaque variable importante de la procédure informatique. Les étapes subséquentes correspondent à l\u0026rsquo;exécution de la procédure.\n  Pour chaque cas de test, on peut soit sélectionner une solution ou la validation du code étudiant. Pour la solution, l\u0026rsquo;icône représente le nombre d\u0026rsquo;étapes contenu dans la solution. Pour le code étudiant, l\u0026rsquo;icône représente le résultat de validation.\n   Symbole  Signification    ✔ Validation réussie   ✗ Erreur de validation   ¤ Plantage lors de la validation    1.1.2.3 Navigation entre les étapes de la procédure #  Pour le cas de test sélectionné, on peut naviguer à travers la séquence d\u0026rsquo;exécution de la procédure. Cette option est particulièrement utile pour détecter une erreur. On peut comparer, étape par étape, le déroulement de la solution au déroulement de procédure implantée par l\u0026rsquo;étudiant·e.\n      À noter que l\u0026rsquo;outil de validation exécute la procédure dès le démarrage Les étapes d\u0026rsquo;exécution sont ainsi mémorisées à l\u0026rsquo;avance. Contrairement à un véritable débogueur, on peut donc reculer dans les étapes d\u0026rsquo;exécution.\n1.1.2.4 Valeurs des variables #  Le panneau des variables montre comment les valeurs importantes pour la procédure évoluent en cours d\u0026rsquo;exécution. Voici un exemple pour quatre étapes.\n   Étape 1 Étape 2         Étape 3 Étape 4         1.1.3 Expérimenter avec les données #  L\u0026rsquo;outil supporte la modification en temps réel du fichier de données correspondant aux cartes affichées. Cette fonctionnalité permet de créer des exercices où les étudiant·e·s doivent encoder des données de façon à produire la bonne visualisation.\n      À noter que l\u0026rsquo;outil sauvegarde les données dans un fichier .json situé dans le répertoire _storage/models (le format JSON est présenté à la Section 1.2.3).\n1.1.4 Trouver des erreurs dans la procédure implantée #  Visualiser la procédure à l\u0026rsquo;aide d\u0026rsquo;une animation aide les étudiant·e·s à trouver certaines erreurs, sutout qu\u0026rsquo;on peut comparer l\u0026rsquo;animation produite pour la solution avec celle produite pour le code étudiant.\nL\u0026rsquo;exemple ci-bas illustre une erreur courante dans le code étudiant. On voit que la procédure correcte s\u0026rsquo;arrête dès que le marqueur bleu (l\u0026rsquo;indice i dans la boucle) dépasse le marqueur rouge (l\u0026rsquo;indice aDeplacer identifiant la carte à déplacer). Dans le code étudiant, cette condition n\u0026rsquo;as pas été codée correctement et la procédure s\u0026rsquo;exécute pour des étapes en trop, ce qui mène à un résultat erroné.\n    Procédure correcte (solution)           Procédure erronée           1.1.5 Afficher le graphe d\u0026rsquo;objets #  Finalement, l\u0026rsquo;outil de validation génère un graphe d\u0026rsquo;objet pour les données courantes et sauvegarde ce graphe dans le répertoire _storage/graphs (voir la Section 1.2.2 à propos des graphes d\u0026rsquo;objets). Ces graphes permettent aux étudiant·e·s de se forger une image mentale de l\u0026rsquo;organisation des données en mémoire. En particulier, puisque les graphes sont générés, les étudiant·e·s peuvent consulter les graphes d\u0026rsquo;objets correspondant à différentes étapes d\u0026rsquo;une procédure.\n   Données JSON   Graphe d'objets     {  \u0026#34;_C\u0026#34;: \u0026#34;MonTableau\u0026#34;,  \u0026#34;aDeplacer\u0026#34;: 3,  \u0026#34;i\u0026#34;: 0,  \u0026#34;cartes\u0026#34;: [  null,  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 5,  \u0026#34;sorte\u0026#34;: \u0026#34;TREFLE\u0026#34;  },  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 3,  \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34;  },  null,  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 7,  \u0026#34;sorte\u0026#34;: \u0026#34;PIQUE\u0026#34;  },  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 2,  \u0026#34;sorte\u0026#34;: \u0026#34;COEUR\u0026#34;  }  ],  \u0026#34;memoireA\u0026#34;: null,  \u0026#34;memoireB\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 2,  \u0026#34;sorte\u0026#34;: \u0026#34;TREFLE\u0026#34;  } }      "},{"id":14,"href":"/efficacite/performance_vs_efficacite/","title":"Performance Vs efficacité","section":"Qu'est-ce que l'efficacité?","content":"Section 3.1: Performance Vs efficacité #  "},{"id":15,"href":"/annexes/annexe_ateliers/deplacer_decaler/","title":"Procédures déplacer/décaler","section":"Annexe 5: exemples d'ateliers","content":"Procédures déplacer/décaler #  Préalable #   JDK 11 ou plus récent (testé jusqu\u0026rsquo;à JDK18) Git Eclipse  Créer le projet #    Télécharger shift.zip\n  Copier le fichier shift.zip à la racine d\u0026rsquo;un répertoire de travail vide\n  Extraire les fichiers directement à la racine de ce répertoire de travail\n  Clic-droit sur le fichier =\u0026gt; Extraire tout\n  Effacer shift du chemin proposé\n  Cliquer sur Extraire\n  Choisir Remplacer les fichiers dans la destination\n  Vérifier que les fichiers sont à la racine du répertoire de travail\n    Ouvrir Git Bash à la racine du répertoire de travail\n Windows 10 : Clic-droit =\u0026gt; Git Bash Here Windows 11 : Clic-droit =\u0026gt; Show more options =\u0026gt; Git Bash Here    En Git Bash, exécuter le script ajouter_atelier.sh\n$ sh scripts/ajouter_atelier.sh   au besoin fermer Eclipse avant d\u0026rsquo;exécuter le script\n  appuyer sur Entrée dans fenêtre Git Bash pour vraiment lancer le script\n    Attendre que le script termine\n  Ouvrir Eclipse et importer le projet shift\n  File =\u0026gt; Import =\u0026gt; Existing Projects into Workspace\n  Cliquer sur Browse et naviguer jusqu\u0026rsquo;à la racine du répertoire de travail\n  Cliquer sur Sélectionner un dossier\n  Vérifier que le projet apparaît dans la case Projects\n  Cliquer sur Finish\n    Créer la classe MonTableau #    Dans Eclipse, sélectionner le projet shift\n  Ajouter la classe suivante au projet shift\n Nom de la classe : MonTableau Ne pas cocher public static ...    Ouvrir la classe MonTableau et ajuster la signature\npublic class MonTableau extends Tableau {   En utilisant le raccourci Ctrl+1, effectuer les tâches suivantes\n  importer la classe Tableau\n  ajouter l\u0026rsquo;annotation @SuppressWarnings(\u0026quot;serial\u0026quot;)\n    Créer la classe Procedure #    Ajouter la classe suivante au projet shift\n Nom de la classe : Procedure cocher public static ...    Ouvrir la classe Procedure et ajuster la signature\npublic class Procedure extends ProcedureDecaler\u0026lt;MonTableau\u0026gt; {   En utilisant le raccourci Ctrl+1, effectuer les tâches suivantes\n  importer la classe ProcedureDecaler\n  ajouter la méthode obligatoire classeMonTableau\n    Ajouter le code suivant à la méthode main\npublic static void main(String[] args) {  NtroClientFx.launch(args); }  utiliser Ctrl+1 pour corriger les erreurs de compilation    Ajouter le code suivant à la méthode classeMonTableau\nprotected Class\u0026lt;MonTableau\u0026gt; classeMonTableau() {  return MonTableau.class; }   Coder les procédures dans la classe MonTableau #    Ouvrir MonTableau\n  Ajouter la méthode suivante :\n@Override public void deplacerDecaler() {  }   Par héritage, MonTableau contient déjà les attributs que vous devez utiliser\n IMPORTANT\n il faut utiliser ces attributs plutôt que des variables  p.ex. utiliser l\u0026rsquo;attribut i dans la boucle for et non une variable int i   sinon l\u0026rsquo;outil de validation ne pourra pas visualiser l\u0026rsquo;exécution de votre code     Coder les deux procédures directement dans la méthode deplacerDecaler\n la méthode deplacerDecaler appelée par l\u0026rsquo;outil de validation pour exécuter une de vos procédures selon la valeur de l\u0026rsquo;attribut insrerAuDebut, votre code devra exécuter la procédure pour déplacer au début, ou sinon la procédure pour déplacer à la fin TRUC ajouter des méthodes privées à votre classe MonTableau et les appeler selon la valeur de insererAuDebut    Exécuter l\u0026rsquo;outil de validation #    Clic-droit sur Procedure.java =\u0026gt; Run As =\u0026gt; Java Application\n  L\u0026rsquo;outil va vous indiquer si votre code est une solution (✔) ou s\u0026rsquo;il contient une ou des erreurs (✗)\n IMPORTANT\n il faut quand même regarder la console pour voir les exceptions de type IndexOutOfBounds ou NullPointerException vous pouvez quand même utiliser le débogueur     Utiliser l\u0026rsquo;outil de validation pour visualiser votre code #    Pour que l\u0026rsquo;outil puisse afficher chacune des étapes de la procédure, vous devez ajouter à la main des instructions Execution.ajouterEtape(), p.ex.\n@Override public void deplacerDecaler() {   i = 0;   Execution.ajouterEtape();   memoireA = cartes[0];   Execution.ajouterEtape(); }  c\u0026rsquo;est à vous de décider ce qui constitue une étape. cela n\u0026rsquo;influence pas la validation, mais vous permet de visualiser ce que votre code fait et pourrait vous aider à trouver des erreurs    Question bonus #    Coder une autre procédure qui implante l\u0026rsquo;opération déplacer au début\n  Avec l\u0026rsquo;outil de validation, comparer le nombre d\u0026rsquo;étapes entre la procédure vue en théorie et la votre\n  Quelle est la différence d\u0026rsquo;efficacité? Est-ce une grosse différence selon vous?\n  "},{"id":16,"href":"/efficacite/temps/","title":"Efficacité en temps","section":"Qu'est-ce que l'efficacité?","content":"Section 3.2: Efficacité en temps #  "},{"id":17,"href":"/approche/langages_et_notations/","title":"Langages et notations utilisées","section":"Présentation de l'approche","content":"Section 1.2: Langages et notations utilisées #  1.2.1 Diagramme de classes et Java #  Nous utilisons le langage de programmation Java pour les exemples de code de ce manuel. Au besoin, nous vous invitons à vous référer à (Mayfield et Downey, 2020) pour une introduction à ce langage.\nPour visualiser les types de données, nous utilisons des digrammes de classe. Voici par exemple un diagramme de classe représentant une liste chaînée simple.\nChaque boîte dénote une classe. Une boîte a typiquement trois sections. La première section à partir du haut est le nom de la classe, p.ex. Liste (lorsque la classe est abstraite, ce nom sera en italique). La deuxième section dénote les méthodes, p.ex. int taille(). La dernière section dénote les attributs, p.ex. int taille. La flèche triangulaire dénote l\u0026rsquo;héritage (le triangle est collé sur la classe parent). Par exemple, la classe ListeChaineeSimple hérite de la classe Liste (puisque Liste est abstraite, on peut aussi dire que ListeChaineeSimple implante une Liste). La flèche avec un losange dénote une référence (le losange est collé sur la classe qui maintient la référence, puis spécifiquement sur l\u0026rsquo;attribut qui maintient cette référence). Par exemple, une ListeChaineeSimple maintient une référence à un MaillonSimple. Plus spécifiquement, c\u0026rsquo;est l\u0026rsquo;attribut tete qui maintient cette référence.\nVoici un autre exemple de diagramme de classes, cette fois-ci d\u0026rsquo;une liste chaînée double.\nÀ note que le MaillonDouble maintient deux références à d\u0026rsquo;autre MaillonDouble (le suivant et le precedent). Quand une classe maintient une référence à des objets de son propre type, on parle alors de types récursifs.\n1.2.2 Graphe d\u0026rsquo;objets #  Le diagramme de classe représente le type de données qu\u0026rsquo;on modélise, mais ne peut pas représenter des données concrètes. Pour ce faire, nous utilisons des graphes d\u0026rsquo;objets.\nVoici un graphe d\u0026rsquo;objet pour une liste chaînée simple.\nChaque boîte dénote un objet. Une boîte a une ou plusieurs sections. La première section à partir du haut dénote la classe de l\u0026rsquo;objet et les sections suivantes dénotent la valeur des différents attributs de cet objet. Par exemple, le graphe ci-haut contient une seule boîte où la classe est ListeChaineeSimple. On dit qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un objet de type ListeChaineeSimple. Les attributs sont taille (valeur 3) et tete (référence à un objet de type MaillonSimple).\nVoici un deuxième exemple de graphe d\u0026rsquo;objets, cette fois-ci pour une liste chaînée double.\nÀ noter comment les références suivant et precedent forment des cycles dans le graphe d\u0026rsquo;objet, ce qui est toujours possibles avec les types récursifs et, en général, dans l\u0026rsquo;organisation en mémoire des données d\u0026rsquo;un programme. Il est important d\u0026rsquo;encourager les étudiant·e·s à garder en tête la possibilité de tels cycles dans les données, puisqu\u0026rsquo;un programme doit les détecter afin de ne pas s\u0026rsquo;exécuter en boucle infinie.\n1.2.3 JSON #  Nous utilisons aussi le format JSON pour représenter les données. JSON veut dire Javascript Object Notation et c\u0026rsquo;est le format privilégié pour les applications Web et les bases de données NoSQL.\nVoici les valeurs en JSON :\n la valeur nulle : null un booléen : true ou false un nombre comme : 1, 4.5, -10.1 une chaîne comme : \u0026quot;asdf\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;Bonjour!\u0026quot;  Voici les structures en JSON :\n une liste comme :  [1, 3, -1] [] [\u0026quot;asfd\u0026quot;, \u0026quot;Bonjour!\u0026quot;, \u0026quot;\u0026quot;]   une objet comme :  {\u0026quot;cle01\u0026quot;:true} {} {\u0026quot;cle01\u0026quot;:true, \u0026quot;cle02\u0026quot;:-12}    Une liste est un tableau qui peut grandir et rapetisser. Une des particularités des la liste JSON est de mélanger les types de valeurs :\n [1,true,\u0026quot;Bonjour!\u0026quot;] [null, \u0026quot;\u0026quot;, 1, false]  Un objet JSON permet d\u0026rsquo;accéder à des valeurs avec des clés (comme un mappage). En JSON, une clé est toujours une chaîne. La valeur peut être n\u0026rsquo;importe quelle valeur JSON\nÀ noter aussi que JSON est un format récursif.\n on peut avoir [1,2,[2,4]] (une liste à l\u0026rsquo;intérieur d\u0026rsquo;une liste) on peut avoir [1,2,[2,[5,423]]] on peut avoir [1,2,[2,[[44,2],423]]] etc.  Voici la même liste chaîne simple que ci-haut, mais dans le format JSON.\n{  \u0026#34;_C\u0026#34;: \u0026#34;ListeChaineeSimple01\u0026#34;,  \u0026#34;taille\u0026#34;: 3,  \u0026#34;tete\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;MaillonSimple\u0026#34;,  \u0026#34;valeur\u0026#34;: \u0026#34;z\u0026#34;,  \u0026#34;suivant\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;MaillonSimple\u0026#34;,  \u0026#34;valeur\u0026#34;: \u0026#34;r\u0026#34;,  \u0026#34;suivant\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;MaillonSimple\u0026#34;,  \u0026#34;valeur\u0026#34;: \u0026#34;w\u0026#34;,  \u0026#34;suivant\u0026#34;: null  }  }  } À noter que JSON ne permet pas de représenter le type de donnée (la classe). Par convention, nous représenterons la classe à l\u0026rsquo;attribut spécial \u0026quot;_C\u0026quot;:\u0026quot;NomDeLaClasse\u0026quot;.\nFinalement, voici la même liste chaînée double que ci-haut, mais exprimée en JSON.\n{  \u0026#34;_C\u0026#34;: \u0026#34;ListeChaineeDouble01\u0026#34;,  \u0026#34;taille\u0026#34;: 3,  \u0026#34;tete\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;MaillonDouble\u0026#34;,  \u0026#34;valeur\u0026#34;: \u0026#34;z\u0026#34;,  \u0026#34;precedent\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;MaillonDouble\u0026#34;,  \u0026#34;valeur\u0026#34;: \u0026#34;w\u0026#34;,  \u0026#34;precedent\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;MaillonDouble\u0026#34;,  \u0026#34;valeur\u0026#34;: \u0026#34;r\u0026#34;,  \u0026#34;precedent\u0026#34;: {  \u0026#34;_R\u0026#34;: \u0026#34;/tete\u0026#34;  },  \u0026#34;suivant\u0026#34;: {  \u0026#34;_R\u0026#34;: \u0026#34;/tete/precedent\u0026#34;  }  },  \u0026#34;suivant\u0026#34;: {  \u0026#34;_R\u0026#34;: \u0026#34;/tete\u0026#34;  }  },  \u0026#34;suivant\u0026#34;: {  \u0026#34;_R\u0026#34;: \u0026#34;/tete/precedent/precedent\u0026#34;  }  } À noter que JSON ne contient de pas de mécanisme officiel pour représenter les références. Par convention, nous représentons une référence grâce à un objet spécial de la forme { \u0026quot;_R\u0026quot;: \u0026quot;/chemin/vers/objet\u0026quot;} où le chemin vers l\u0026rsquo;objet permet de l\u0026rsquo;identifier à partir de la racine du fichier JSON.\n"},{"id":18,"href":"/listes/chainee_simple/","title":"Liste chaînée simple","section":"Comprendre les listes","content":"Section 4.3: Liste chaînée simple #  "},{"id":19,"href":"/annexes/annexe_ateliers/fibonacci/","title":"Modéliser la suite de Fibonacci","section":"Annexe 5: exemples d'ateliers","content":"Modéliser la suite de Fibonacci #  Préalable #   JDK 11 ou plus récent (testé jusqu\u0026rsquo;à JDK18) Git Eclipse  Créer le projet #    Télécharger fibonacci.zip\n  Copier le fichier fiboacci.zip à la racine d\u0026rsquo;un répertoire de travail vide\n  Extraire les fichiers directement à la racine de ce répertoire de travail\n  Clic-droit sur le fichier =\u0026gt; Extraire tout\n  Effacer fibonacci du chemin proposé\n  Cliquer sur Extraire\n  Choisir Remplacer les fichiers dans la destination\n  Vérifier que les fichiers sont à la racine du répertoire de travail\n    Ouvrir Git Bash à la racine de mon répertoire de travail\n Windows 10 : Clic-droit =\u0026gt; Git Bash Here Windows 11 : Clic-droit =\u0026gt; Show more options =\u0026gt; Git Bash Here    En Git Bash, exécuter le script ajouter_atelier.sh\n$ sh scripts/ajouter_atelier.sh   au besoin fermer Eclipse avant d\u0026rsquo;exécuter le script\n  appuyer sur Entrée dans fenêtre Git Bash pour vraiment lancer le script\n    Attendre que le script termine\n  Ouvrir Eclipse et importer le projet fibonacci\n  File =\u0026gt; Import =\u0026gt; Existing Projects into Workspace\n  Cliquer sur Browse et naviguer jusqu\u0026rsquo;à la racine de mon dépôt Git\n  Cliquer sur Sélectionner un dossier\n  Vérifier que le projet fibonacci apparaît dans la case Projects\n  Cliquer sur Finish\n    Créer la classe MonFibonacci #    Ajouter la classe suivante au projet fibonacci\n Nom de la classe : MonFibonacci Ne pas cocher public static ...    Ouvrir la classe MonFibonacci et ajuster la signature\npublic class MonFibonacci extends Fibonacci {   En utilisant le raccourci Ctrl+1, effectuer les tâches suivantes\n  importer la classe Fibonacci\n  ajouter l\u0026rsquo;annotation @SuppressWarnings(\u0026quot;serial\u0026quot;)\n    Ajouter la méthode calculerReponseEtNombreOr\n@Override public void calculerReponseEtNombreOr() {  }   Ajouter la méthode construireGrapheRecursivement\n@Override public void construireGrapheRecursivement() {  }   Créer la classe MonCalculateur #    Ajouter la classe suivante au projet atelier2_3\n Nom de la classe : MonCalculateur Ne pas cocher public static ...    Ouvrir la classe MonCalculateur et ajuster la signature\npublic class MonCalculateur extends Calculateur {   En utilisant le raccourci Ctrl+1, effectuer les tâches suivantes\n  importer la classe Calculateur\n  ajouter l\u0026rsquo;annotation @SuppressWarnings(\u0026quot;serial\u0026quot;)\n    Ajouter la méthode construireGraphe\n@Override public void construireGraphe() {  if(siRecursif) {   // construire le graphe récursivement   }else {   // construire le graphe dynamiquement   } }   Créer la classe Procedure #    Ajouter la classe suivante au projet fibonacci\n Nom de la classe : Procedure cocher public static ...    Ouvrir la classe Procedure et ajuster la signature\npublic class Procedure extends FibonacciProcedureApp\u0026lt;MonCalculateur, MonFibonacci\u0026gt; {   En utilisant le raccourci Ctrl+1, effectuer les tâches suivantes\n  importer la classe FibonacciProcedureApp\n  ajouter la méthode obligatoire classeCalculateur\n  ajouter la méthode obligatoire classeFibonacci\n    Ajouter le code suivant à la méthode main\npublic static void main(String[] args) {  NtroClientFx.launch(args); }  utiliser Ctrl+1 pour corriger les erreurs de compilation    Ajouter le code suivant à la méthode classeCalculateur\n@Override protected Class\u0026lt;MonCalculateur\u0026gt; classeCalculateur() {  return MonCalculateur.class; }   Ajouter le code suivant à la méthode classeFibonacci\n@Override protected Class\u0026lt;MonFibonacci\u0026gt; classeFibonacci() {  return MonFibonacci.class; }   Exécuter l\u0026rsquo;outil de validation une première fois #    Dans Eclipse, sélectionner le projet fibonacci\n  Clic-droit sur la classe Procedure\n Run As =\u0026gt; Java Application    Compléter la version récursive #    Compléter la méthode calculerReponseEtNombreOr\n  Compléter la méthode construireGrapheRecursivement\n  Compléter la méthode construireGraphe, version récursive\n  Exécuter l\u0026rsquo;outil de validation pour tester mon code\n  Compléter la méthode construireGraphe, version dynamique #    Voici des graphes pour m\u0026rsquo;aider à implanter la création de la nouvelle tête\n  Utiliser une variable nouvelleTete\n  Créer un nouvel objet MonFibonacci\n  Le moinsUn de la nouvelleTete doit pointer vers la tete actuelle\n  (et le moinsDeux de la nouvelleTete doit pointer vers le moinUn de la tete actuelle)\n    La tete devient maintenant la nouvelleTete\n  Calculer la réponse avant de continuer la boucle\n    Exécuter l\u0026rsquo;outil de validation pour tester mon code\n  Question bonus : modélisation plus simple #    Utiliser une modélisation plus simple pour calculer la suite de Fibonacci\n  Pour valider, construire le même graphe d\u0026rsquo;objets à partir de la modélisation plus simple\n  "},{"id":20,"href":"/modelisation/_brouillons/modele/","title":"Notion de modèle","section":"Modélisation des données et limitations de l'approche","content":"Notion de modèle #  %!s().1 Notion de modèle #    Un modèle est une classe qui représente des données importantes pour un programme\n  Prenons par exemple un petit tableau de cartes issu de l\u0026rsquo;atelier 1.1 :\n  Le modèle est la classe MonTriLibre\n  Il faut aussi les objets Carte pour bien représenter les données\n  Les classes complémentaires comme Carte sont parfois appelées des valeurs (ou des sous-modèles)\n  %!s().2 Un modèle a des comportements (méthodes) #    Comme MonTriLibre est une classe, le modèle contient aussi des méthodes\n  Par exemple :\n boolean isSorted pour déterminer si les cartes sont triées int testCaseSize qui retourne la taille de l\u0026rsquo;exemple (le nombre de cartes)    La valeur Carte contient aussi des méthodes, par exemple :\n int compareTo pour indiquer si la carte est plus petite qu\u0026rsquo;une autre carte boolean isNullCard pour indier s\u0026rsquo;il s\u0026rsquo;agit vraiment d\u0026rsquo;une carte ou d\u0026rsquo;une case vide    On va voir à la session suivante qu\u0026rsquo;une application graphique est souvent divisée en trois parties :\n le modèle : contient les données et les méthodes pour manipuler les données la vue : contient le code pour afficher les données le contrôleur : contient le code pour créer les vues et les modèles et autres tâches    %!s().3 Une application a souvent plusieurs modèles #    Par exemple, l\u0026rsquo;outil de validation a un modèle a trois modèles\n un modèle pour les cartes et un pour les cas de tests   un modèle pour des paramètres    %!s().4 Modèle en JSON #    JSON n\u0026rsquo;a pas de notion de classe\n  Dans ce cours, on va utiliser la clé spéciale _C pour identifier la classe\n  On a donc la représentation JSON suivante pour un 4♧ :\n{  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 4,  \u0026#34;sorte\u0026#34;: \u0026#34;TREFLE\u0026#34; }   Et le JSON suivant pour une liste de trois cartes\n[  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 5,  \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34;  },  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 4,  \u0026#34;sorte\u0026#34;: \u0026#34;TREFLE\u0026#34;  },  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 6,  \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34;  } ]   Et finalement le JSON suivant pour le modèle MonTriLibre\n  {  \u0026#34;_C\u0026#34;: \u0026#34;MonTriLibre\u0026#34;,  \u0026#34;cartes\u0026#34;: [  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 5,  \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34;  },  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 4,  \u0026#34;sorte\u0026#34;: \u0026#34;TREFLE\u0026#34;  },  {  \u0026#34;_C\u0026#34;: \u0026#34;Carte\u0026#34;,  \u0026#34;numero\u0026#34;: 6,  \u0026#34;sorte\u0026#34;: \u0026#34;CARREAU\u0026#34;  }  ],  \u0026#34;siTrie\u0026#34;: false } "},{"id":21,"href":"/approche/","title":"Présentation de l'approche","section":"Code les cartes!","content":"Chapitre 1: Présentation de l\u0026rsquo;approche #   Ce chapitre développe l\u0026rsquo;approche pédagogique offerte par ce manuel.\n Aperçu du chapitre    Section 1.1   L\u0026rsquo;outil de validation permet de visualiser les étapes d\u0026rsquo;une procédure informatique à l\u0026rsquo;aide de schémas où figurent des cartes à jouer. On peut exécuter la procédure étape par étape, ce qui permet de créer une animation où les cartes à jouer bougent à l\u0026rsquo;écran et illustrent la procédure. À noter que ces schémas et ces animations sont créés à partir du code fourni par l\u0026rsquo;utilisateur. Les étudiant·e·s peuvent dont utiliser l\u0026rsquo;outil de validation pour comprendre analyser certaines de leurs erreurs.\n    Section 1.2   Tous les exemples de code de ce manuel sont en Java (c'est aussi le langage avec lequel est programmé l'outil de validation). De plus, nous utilisons des diagrammes de classe pour modéliser des types de données et des graphes d'objets pour représenter des exemples de données. Finalement, nous utilisons le format JSON pour représenter des données sous forme textuelle (c'est aussi le format de données qu'utilise l'outil de validation).     Section 1.3   Dans l'approche présentée, il n'y pas de façon unique de visualiser des données avec des cartes à jouer. Pour chaque procédure qu'on veut présenter en classe, il faut créer une visualisation et l'ajouter à l'outil de validation. Cette section donne deux exemples de telles visualisations, alors que l'Annexe 3 explique comment ajouter une nouvelle visualisation à l'outil.    "},{"id":22,"href":"/modelisation/tableau_d_objets/","title":"Tableaux d'objets","section":"Modélisation des données et limitations de l'approche","content":"Section 2.2: Tableaux d\u0026rsquo;objets #  Une fois les objets modélisés, la prochaine étape est de spécifier les relations entre ces objets, c\u0026rsquo;est-à-dire l\u0026rsquo;organisation de ces objets dans la mémoire du programme.\n2.2.1 Tableau de personnages #  On peut améliorer la modélisation d\u0026rsquo;un film présentée au chapitre précédent en ajoutant la relation suivante :\n Un film contient des personnages  Voici des exemples de données se conformant à cette modélisation.\n     {  \u0026#34;_C\u0026#34;: \u0026#34;Film\u0026#34;,  \u0026#34;titre\u0026#34;: \u0026#34;Dr. No\u0026#34;,  \u0026#34;annee\u0026#34;: 1962,  \u0026#34;personnages\u0026#34;: [  {  \u0026#34;_C\u0026#34;: \u0026#34;PersonnageObjet\u0026#34;,  \u0026#34;nom\u0026#34;: \u0026#34;James Bond\u0026#34;,  \u0026#34;personnagePrincipal\u0026#34;: true  },  {  \u0026#34;_C\u0026#34;: \u0026#34;PersonnageObjet\u0026#34;,  \u0026#34;nom\u0026#34;: \u0026#34;Docteur No\u0026#34;,  \u0026#34;personnagePrincipal\u0026#34;: false  }  ]       {  \u0026#34;_C\u0026#34;: \u0026#34;Film\u0026#34;,  \u0026#34;titre\u0026#34;: \u0026#34;Bons Baisers de Russie\u0026#34;,  \u0026#34;annee\u0026#34;: 1963,  \u0026#34;personnages\u0026#34;: [  {  \u0026#34;_C\u0026#34;: \u0026#34;PersonnageObjet\u0026#34;,  \u0026#34;nom\u0026#34;: \u0026#34;James Bond\u0026#34;,  \u0026#34;personnagePrincipal\u0026#34;: true  },  {  \u0026#34;_C\u0026#34;: \u0026#34;PersonnageObjet\u0026#34;,  \u0026#34;nom\u0026#34;: \u0026#34;Rosa Klebb\u0026#34;,  \u0026#34;personnagePrincipal\u0026#34;: false  }  ]    2.2.2 Tableau de films #  On peut améliorer la modélisation d\u0026rsquo;un personnage présentée au chapitre précédent en ajoutant la relation suivante :\n Un personnage apparaît un ou plusieurs films  Voici des exemples de données se conformant à cette modélisation.\n     {  \u0026#34;_C\u0026#34;: \u0026#34;Personnage\u0026#34;,  \u0026#34;nom\u0026#34;: \u0026#34;James Bond\u0026#34;,  \u0026#34;personnagePrincipal\u0026#34;: true,  \u0026#34;films\u0026#34;: [  {  \u0026#34;_C\u0026#34;: \u0026#34;FilmObjet\u0026#34;,  \u0026#34;titre\u0026#34;: \u0026#34;Dr. No\u0026#34;,  \u0026#34;annee\u0026#34;: 1962  },  {  \u0026#34;_C\u0026#34;: \u0026#34;FilmObjet\u0026#34;,  \u0026#34;titre\u0026#34;: \u0026#34;Bons Baisers de Russie\u0026#34;,  \u0026#34;annee\u0026#34;: 1963  }  ]       {  \u0026#34;_C\u0026#34;: \u0026#34;Personnage\u0026#34;,  \u0026#34;nom\u0026#34;: \u0026#34;Docteur No\u0026#34;,  \u0026#34;personnagePrincipal\u0026#34;: false,  \u0026#34;films\u0026#34;: [  {  \u0026#34;_C\u0026#34;: \u0026#34;FilmObjet\u0026#34;,  \u0026#34;titre\u0026#34;: \u0026#34;Dr. No\u0026#34;,  \u0026#34;annee\u0026#34;: 1962  }  ]    2.2.3 Tableau de cartes #  Les exemples de tableau de cartes sont plus pertinents à notre approche. Considérer le digramme de classe suivant.\nVoici des exemples de tableau de cartes.\n              2.2.4 Comprendre l\u0026rsquo;effet d\u0026rsquo;instructions typiques #  Pour comprendre comment les cartes sont animées dans l\u0026rsquo;outil de validation, il est important de comprendre l\u0026rsquo;effet d\u0026rsquo;instructions typiques.\n2.2.4.1 Accéder à une valeur #    Objets au départ Instructions Résultat      memoireA.getNumero(); memoireA.getSorte();   5 \u0026#34;TREFLE\u0026#34;      Objets au départ Instructions Résultat      cartes[2].getNumero(); cartes[2].getSorte();   3 \u0026#34;CARREAU\u0026#34;      Objets au départ Instructions Résultat      cartes[2].getNumero(); memoireB.getNumero();   java.lang.NullPointerException java.lang.NullPointerException    2.2.4.2 Déplacer un objet (déplacer une carte) #    Objets au départ Instruction Résultat      memoireA = cartes[0]; cartes[0] = null;        Objets au départ Instruction Résultat      cartes[2] = cartes[0]; cartes[0] = null;      2.2.4.3 Copier la référence à un objet #    Objets au départ Instruction Résultat      memoireA = cartes[0];        Objets au départ Instruction Résultat      cartes[2] = cartes[0];      2.2.4.4 Créer un nouvel objet (créer une nouvelle carte) #    Objets au départ Instruction Résultat      memoireA = new Carte(2, \u0026#34;TREFLE\u0026#34;);        Objets au départ Instruction Résultat      memoireB = new Carte(5, \u0026#34;TREFLE\u0026#34;);      2.2.5 Références multiples #  Typiquement, on va copier une référence à un objet, plutôt que déplacer l\u0026rsquo;objet.\n   Typique   Plus rare     memoireA = cartes[0];   memoireA = cartes[0]; cartes[0] = null;    Le résultat est qu\u0026rsquo;on a des références multiples: plusieurs références vers le même objet.\nSi on visualise du code typique avec les cartes, on va visualiser les références multiples en affichant plusieurs copies d\u0026rsquo;une carte.\n      La visualisation est correcte, mais plus difficile à lire.\nAutant que possible, on va expliquer les procédures en déplaçant les cartes, c\u0026rsquo;est-à-dire en évitant de créer des références multiples. Cependant, il faut garder en tête que le code typique contient très souvent des références multiples.\n"},{"id":23,"href":"/modelisation/graphe_d_objets/","title":"Graphes d'objets","section":"Modélisation des données et limitations de l'approche","content":"Section 2.3: Graphes d\u0026rsquo;objets #  Dans le cas général, des données orientée-objet forme un graphe.\n2.3.1 Graphe film/personnage #  On peut compléter ainsi la modélisation des films et des personnages présentées aux chapitres précédents.\n Un Personnage apparaît dans plusieurs Film Un Film contient plusieurs Personnage  Voici un exemple de données se conformant à cette modélisation.\n Le Personnage James Bond apparaît dans deux films : Dr. No et Bon Baisers de Russie Le Film Dr. No contient deux personnages : James Bond et Dr. No  2.3.2 Exemple : Fibonacci #  Dans le cas général, il n\u0026rsquo;est pas facile de visualiser un graphe d\u0026rsquo;objet avec des cartes. Dans notre approche, il est donc nécessaire de s\u0026rsquo;en tenir à des cas particuliers. Comme exemple, nous développons une modélisation de la séquence de Fibonacci.\n2.3.3 Définition #  Voici le début de la suite de Fibonacci :\n0 1 1 2 3 5 8 13 21 34 55 89 144 ... La définition mathématique est récursive :\n  \\( F_0 = 0\\\\~\\\\ F_1 = 1\\\\~\\\\ F_n = F_{n-1} \u0026#43; F_{n-2}\\\\~\\\\ \\)   Autrement dit :\n  0 et 1 sont deux cas spéciaux\n  sinon le prochain nombre de la suite est toujours l\u0026rsquo;addition deux nombres précédents\n  2.3.4 Nombre d\u0026rsquo;or #    La suite de Fibonacci est utilisée pour calculer le nombre d\u0026rsquo;or, soit environs 1.618\n (le nombre d\u0026rsquo;or est reconnu, entre autres choses, comme une proportion hauteur/largeur agréable à l\u0026rsquo;oeil)    Comme pour π, on peut le calculer le nombre d\u0026rsquo;or avec autant que précision que désiré\n (c.-à-d. avec autant de chiffres après le point que désiré)    Pour calculer une approximation du nombre d\u0026rsquo;or on fait tout simplement :\n\\( \\text{nombre d\u0026#39;or} \\approx \\dfrac{F_{n}}{F_{n-1}} \\text{~~~pour~~~} n\\geq 2 \\)    Plus on prend un n élevé, plus la précision est bonne\n  Autrement dit, le nombre d\u0026rsquo;or est à peu près égal à :\n  un nombre de la suite de Fibonacci, divisé par le nombre qui le précède\n  (plus on prend un nombre loin dans la suite, plus l\u0026rsquo;approximation est bonne)\n    2.3.5 Modéliser la suite de Fibonacci #   Pour modéliser la suite en Java, on va créer une structure de données récursive      Pour n = 0, on a le graphe d\u0026rsquo;objets suivant\n  Pour n = 1, on a le graphe d\u0026rsquo;objets suivant\n  Pour n = 2, on a le graphe d\u0026rsquo;objets suivant\n NOTE : la suite se lit de droite à gauche    Pour n = 3, on a le graphe d\u0026rsquo;objets suivant\n  Et ainsi de suite\u0026hellip;\n  2.3.6 Pour calculer la réponse et le nombre d\u0026rsquo;or #    Calculer la réponse pour n \u0026gt;= 2 est simple\nreponse = moinsUn.getReponse() + moinsDeux.getReponse();   Même chose pour le nombre d\u0026rsquo;or\nnombreOr = Double.valueOf(reponse) / Double.valueOf(moinsUn.getReponse());   Le défi est qu\u0026rsquo;il faut d\u0026rsquo;abord construire le graphe d\u0026rsquo;objet\n  2.3.7 Construire le graphe d\u0026rsquo;objets récursivement #    Avec des appels récursifs, on va construire d\u0026rsquo;abord, puis calculer\n    on crée d\u0026rsquo;abord l\u0026rsquo;objet n, puis n-1, et ainsi de suite jusqu\u0026rsquo;à l\u0026rsquo;objet 0    Pour le cas n \u0026gt;= 2, voici comment procéder\n  créer un nouvel objet MonFibonacci et le mémoriser dans moinsUn\n  enregistrer que le n de ce moinsUn est n-1 (le n courant moins 1)\n  créer le reste du graphe récursivement en appelant moinsUn.construireGrapheRecursivement()\n  enregister que le moinsDeux courant est moinsUn.getMoinsUn() (le moinsUn du moinsUn courant)\n  calculer la réponse courante à partir des réponses de moinsUn et moinsDeux\n    L\u0026rsquo;appel récursif est plus proche de la définition mathématique\n (pour calculer la réponse en n, il faut d\u0026rsquo;abord calculer la réponse en n-1)    L\u0026rsquo;inconvénient est qu\u0026rsquo;on peut déborder la pile d\u0026rsquo;appel\nException in thread \u0026#34;main\u0026#34; java.lang.StackOverflowError at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) at ca.ntro.cards.fibonacci.solution.MonFibonacci.construireGrapheRecursivement(MonFibonacci.java:31) ...  RAPPEL : le code n\u0026rsquo;est pas bogué, mais limité par la mémoire attribuée à la pile d\u0026rsquo;appel    2.3.8 Construire le graphe d\u0026rsquo;objets dynamiquement #    En programmation dynamique, on calcule en même temps qu\u0026rsquo;on construit\n    on crée d\u0026rsquo;abord l\u0026rsquo;objet 0, puis 1, et ainsi de suite jusqu\u0026rsquo;à l\u0026rsquo;objet n    L\u0026rsquo;idée est qu\u0026rsquo;on fait une boucle pour créer le graphe d\u0026rsquo;objets\n  on crée une nouvelleTete\n  le moinsUn de la nouvelleTete est l\u0026rsquo;ancienne tete\n  le moinsDeux de la nouvelleTete est le moinsUn de l\u0026rsquo;ancienne tete\n  c.-à-d. on insère la nouvelleTete à gauche, et on « pousse » les objets existants vers la droite\n    Pour le cas n \u0026gt;= 2, voici comment procéder\n  pour chaque i allant de 2 à n (inclusivement)\n  créer un nouvel objet MonFibonacci pour représenter la nouvelleTete\n  enregistrer que le n de la nouvelleTete est i\n  enregistrer que le moinsUn de la nouvelleTete est la tete courante\n  enregistrer que le moinsDeux de la nouvelleTete est le moinsUn de la tete courante\n  enregistrer que tete pointe maintenant vers la nouvelleTete\n  calculer la réponse pour tete\n      Le calcul dynamique est moins intuitif (et moins proche de la définition mathématique), mais\n on a éliminé l\u0026rsquo;appel récursif, alors on ne peut plus déborder la pile d\u0026rsquo;appel    "},{"id":24,"href":"/listes/chainee_double/","title":"Liste chaînée double","section":"Comprendre les listes","content":"Section 4.4: Liste chaînée double #  "},{"id":25,"href":"/annexes/annexe_ateliers/liste_tableau/","title":"Liste par tableau","section":"Annexe 5: exemples d'ateliers","content":"Liste par tableau #  "},{"id":26,"href":"/modelisation/","title":"Modélisation des données et limitations de l'approche","section":"Code les cartes!","content":"Chapitre 2: Modélisation des données et limitations de l\u0026rsquo;approche #   Ce chapitre présente des exemples de modélisations de données et discute de leur visualisation avec des cartes à jouer, ainsi que l\u0026rsquo;utilisation de ces visualisations en classe ou dans des exercices. À travers le chapitre, nous discutons aussi des limitations d\u0026rsquo;une visualisation avec des cartes à jouer sont aussi discutées à travers le chapitre.\n Aperçu du chapitre    Section 2.1   Ce manuel adopte la vision orienté-objet des données\u0026nbsp;: la composante de base d'une modélisation est un objet. Chaque objet a un type et une collection d'attributs. Chaque attribut a un nom et une valeur. Par exemple, le cinq de coeur est un objet de type «\u0026nbsp;carte à jouer\u0026nbsp;» qui a deux attributs\u0026nbsp;: sa sorte (coeur) et son numéro (cinq).     Section 2.2   Cette section discute de la notion de tableau d'objets (ou liste d'objets). Cette structure est facile à visualiser avec des cartes à jouer\u0026nbsp;: il suffit de placer les cartes une à la suite de l'autre, par exemple de gauche à droite.     Section 2.3   En général, les objets ne sont pas toujours organisés en séquence. Plutôt, chaque objet peut faire référence à un ou plusieurs autres objets et l'organisation des données en mémoire ressemble à un graphe où chaque noeud est un objet. Dans le cas général, il n'y a donc pas nécessairement de visualisation simple avec des cartes à jouer et on doit procéder au cas par cas.    "},{"id":27,"href":"/approche/cartes_a_jouer/","title":"Visualisations avec des cartes à jouer","section":"Présentation de l'approche","content":"Section 1.3: Visualisations avec des cartes à jouer #  Dans notre approche, il n\u0026rsquo;y a pas de façon unique de visualiser les données d\u0026rsquo;une procédure informatique avec des cartes à jouer. Pour chaque procédure, il faut donc spécifier la visualisation à utiliser (l\u0026rsquo;Annexe 3 explique comment programmer une nouvelle visualisation). Nous donnons ici deux exemples de telles visualisations.\n1.3.1 Liste ou tableau à une dimension #  Lorsque les données sont sous la forme d\u0026rsquo;une liste (ou d\u0026rsquo;un tableau à une dimension), on peut facilement visualiser cette liste par une séquence de cartes disposées, par exemple, de gauche à droite. On peut aussi utiliser des marqueurs (petits objets) pour représenter des positions (indices) dans cette liste.\nPar exemple, le code suivant :\nCarte[] cartes;  int aDeplacer; int i;  Carte memoireA; Carte memoireB; Est aisément visualiser par les cartes et les marqueurs suivants :\nÀ noter qu\u0026rsquo;une carte blanche représente une case vide (valeur null).\n1.3.2 Arbre #  Dans le cas où les données sont organisées sous forme d\u0026rsquo;arbre, on peut visualiser les données en disposant aussi les cartes en forme d\u0026rsquo;arbre.\nPar exemple, l\u0026rsquo;arbre suivant (racine en haut, comme le veut la convention) :\nSerait visualisé par les cartes suivantes :\nÀ noter que la visualisation dépend d\u0026rsquo;une compréhension préalable de la notion d\u0026rsquo;arbre (de la forme d\u0026rsquo;un arbre). Cette compréhension préalable risque d\u0026rsquo;être moins acquise chez les étudiant·e·s que celle de séquence utilisée ci-haut. Néanmoins, utiliser des cartes peut s\u0026rsquo;avérer plus intuitifs pour les novices que le format textuel. Par exemple, voici le même arbre en JSON :\n{  \u0026#34;_C\u0026#34;: \u0026#34;Noeud\u0026#34;,  \u0026#34;valeur\u0026#34;: 4,  \u0026#34;enfantGauche\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;Noeud\u0026#34;,  \u0026#34;valeur\u0026#34;: 2,  \u0026#34;enfantGauche\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;Noeud\u0026#34;,  \u0026#34;valeur\u0026#34;: 1,  \u0026#34;enfantGauche\u0026#34;: null,  \u0026#34;enfantDroit\u0026#34;: null  },  \u0026#34;enfantDroit\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;Noeud\u0026#34;,  \u0026#34;valeur\u0026#34;: 3,  \u0026#34;enfantGauche\u0026#34;: null,  \u0026#34;enfantDroit\u0026#34;: null  }  },  \u0026#34;enfantDroit\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;Noeud\u0026#34;,  \u0026#34;valeur\u0026#34;: 6,  \u0026#34;enfantGauche\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;Noeud\u0026#34;,  \u0026#34;valeur\u0026#34;: 5,  \u0026#34;enfantGauche\u0026#34;: null,  \u0026#34;enfantDroit\u0026#34;: null  },  \u0026#34;enfantDroit\u0026#34;: {  \u0026#34;_C\u0026#34;: \u0026#34;Noeud\u0026#34;,  \u0026#34;valeur\u0026#34;: 7,  \u0026#34;enfantGauche\u0026#34;: null,  \u0026#34;enfantDroit\u0026#34;: null  }  } } "},{"id":28,"href":"/annexes/annexe_ateliers/arbre_binaire/","title":"Arbre binaire","section":"Annexe 5: exemples d'ateliers","content":"Arbre binaire #  "},{"id":29,"href":"/efficacite/espace/","title":"Efficacité en espace","section":"Qu'est-ce que l'efficacité?","content":"Section 3.3: Efficacité en espace #  "},{"id":30,"href":"/efficacite/","title":"Qu'est-ce que l'efficacité?","section":"Code les cartes!","content":"Chapitre 3: Qu\u0026rsquo;est-ce que l\u0026rsquo;efficacité? #  "},{"id":31,"href":"/listes/","title":"Comprendre les listes","section":"Code les cartes!","content":"Chapitre 4: Comprendre les listes #  "},{"id":32,"href":"/modelisation/_brouillons/structures/","title":"Structures en Java","section":"Modélisation des données et limitations de l'approche","content":"Structures en Java #   NOTE :\n on va voir les paramètres de types plus en détail à l\u0026rsquo;étape 3     Le JDK Java contient plusieurs structures de données déjà codées\n  Dans ce cours, on va se concentrer sur les deux principales :\n List\u0026lt;E\u0026gt; : une liste Map\u0026lt;K,V\u0026gt; : un dictionnaire (mappage)    À partir de maintenant, vous devriez :\n presque toujours utiliser une List\u0026lt;Integer\u0026gt; et jamais un tableau int[] presque toujours utiliser les structures fournies dans le JDK Java    Exception : pour des raisons pédagogiques\n p.ex. pour comprendre comment coder une liste    Exception : dans des cas bien précis où on a besoin de notre propre structure de données\n p.ex. liste d\u0026rsquo;objets 2d conçue pour détection de collision    %!s().1 List\u0026lt;E\u0026gt; : liste en Java #   Exemple d\u0026rsquo;utilisation :  // interface implantation  List\u0026lt;String\u0026gt; listeChaines = new ArrayList\u0026lt;\u0026gt;();  List\u0026lt;Double\u0026gt; listeReels = new LinkedList\u0026lt;\u0026gt;();   listeChaines.add(\u0026#34;sdf\u0026#34;); // ajoute à la fin listeChaines.add(\u0026#34;34g\u0026#34;); listeChaines.add(\u0026#34;j554\u0026#34;); listeChaines.add(9,\u0026#34;asdf\u0026#34;); // nouvel élément listeChaines.set(9,\u0026#34;asdf\u0026#34;); // change la valeur  String chaine = listeChaines.get(2);  Extrait de l\u0026rsquo;interface :  public interface List\u0026lt;E extends Object\u0026gt; extends Collection\u0026lt;E\u0026gt;{   boolean add(E e); // ajoute à la fin  void add(int i, E e); // insère une nouvelle valeur à la position i  void set(int i, E e); // modifie la valeur à la position i  E get(int i); // obtenir la valeur à la position i  void clear(); // vide la liste  int size(); // taille de la liste  boolean isEmpty(); // si vide  boolean contains(Object o); // si la liste contient la valeur o  int indexOf(Object o); // indice de la valeur o    //... }  Documentation complète :  https://docs.oracle.com/javase/8/docs/api/java/util/List.html    %!s().2 Implantations de List\u0026lt;E\u0026gt; #    List\u0026lt;E\u0026gt; est une interface\n  Le JDK Java fournit différentes implantations, p.ex :\n ArrayList\u0026lt;E\u0026gt; LinkedList\u0026lt;E\u0026gt;    Pour l\u0026rsquo;instant, on va utiliser ArrayList\u0026lt;E\u0026gt;\n  Quelle est la différence?\n à utiliser : aucune (c\u0026rsquo;est la même interface) en terme d\u0026rsquo;efficacité? à coder?  on va en parler à l\u0026rsquo;étape 4      %!s().3 Map\u0026lt;K,V\u0026gt; : mappage en Java #    Les clés d\u0026rsquo;un mappage peuvent être de n\u0026rsquo;importe quel type\n contrairement à notre Dictionnaire où les clés étaients toujours des chaînes    Il y a deux paramètres de types :\n K : le type des clés V : le type des valeurs    IMPORTANT : une clé est associée à une seule valeur\n  Exemple d\u0026rsquo;utilisation :\n  // interface implantation  Map\u0026lt;String, Object\u0026gt; objetJson = new HashMap\u0026lt;\u0026gt;();  Map\u0026lt;Integer, String\u0026gt; parDA = new TreeMap\u0026lt;\u0026gt;();  Map\u0026lt;StudentId, Billet\u0026gt; rendezVous = new LinkedHashMap\u0026lt;\u0026gt;();  objetJson.put(\u0026#34;attr01\u0026#34;, true); objetJson.put(\u0026#34;attr02\u0026#34;, null); objetJson.put(\u0026#34;attr03\u0026#34;, 123.4);  Object valeur01 = objetJson.get(\u0026#34;attr01\u0026#34;);  parDA.put(421235, \u0026#34;Amina\u0026#34;); parDA.put(413354, \u0026#34;Bénison\u0026#34;); parDA.put(565624, \u0026#34;Carlos\u0026#34;); parDA.put(645143, \u0026#34;Delpine\u0026#34;);  String nomEtudiant = parDA.get(413354);  StudentId id = new StudentId(645143);  rendezVous.put(id, new rendezVous()); rendezVous.get(id);   NOTE : on utilise la notation \u0026lt;P1, P2\u0026gt; quand il y a plusieurs paramètres de type\n  Extrait de l\u0026rsquo;interface :\n  public interface Map\u0026lt;K extends Object, V extends Object\u0026gt; {   V put(K c, V v); // associe la valeur v à la clé c  V get(K c); // obtenir la valeur associée à la clé c  void clear(); // vide le map  int size(); // taille du map  boolean isEmpty(); // si vide  boolean containsKey(Object c); // si le map contient la clé c  boolean containsValue(Object v); // si le map contient la valeur v   //... }  Documentation complète :  https://docs.oracle.com/javase/8/docs/api/java/util/Map.html    %!s().4 Implantations de Map\u0026lt;K,V\u0026gt; #    Le JDK Java fournit différentes implantations, p.ex :\n HashMap\u0026lt;K,V\u0026gt; TreeMap\u0026lt;K,V\u0026gt; LinkedHashMap\u0026lt;K,V\u0026gt;    Quelle est la différence?\n à utiliser : presqu\u0026rsquo;aucune (*) à coder? en terme d\u0026rsquo;efficacité?  on en parle à l\u0026rsquo;étape 5      (*) LinkedHashMap est un cas spécial :\n en plus d\u0026rsquo;implanter l\u0026rsquo;interface Map\u0026lt;K,V\u0026gt;, on ajoute la promesse suivante :  il est possible d\u0026rsquo;accéder aux clés dans l\u0026rsquo;ordre où elles ont été insérées      %!s().5 Encoder des données JSON en Java #    Une liste JSON est représenté en Java par List\u0026lt;Object\u0026gt;\n  Un objet JSON est représenté en Java par Map\u0026lt;String, Object\u0026gt;\n  Par exemple :\n  {  \u0026#34;_C\u0026#34;: \u0026#34;MesDonneesJson\u0026#34;,  \u0026#34;racine\u0026#34;: {  \u0026#34;vehicules\u0026#34;: [  {  \u0026#34;nombreDeRoues\u0026#34;: 2,  \u0026#34;type\u0026#34;: \u0026#34;mobilette\u0026#34;,  \u0026#34;etat\u0026#34;: {  \u0026#34;besoinChangementHuile\u0026#34;: false,  \u0026#34;kilometrage\u0026#34;: 14.45  }  },  {  \u0026#34;nombreDeRoues\u0026#34;: 4,  \u0026#34;type\u0026#34;: \u0026#34;camion\u0026#34;,  \u0026#34;etat\u0026#34;: {  \u0026#34;besoinChangementHuile\u0026#34;: true,  \u0026#34;kilometrage\u0026#34;: 13344.5  }  }  ]  } } public class MesDonneesJava extends DonneesJava {   @Override  public void initialiser(){   Map\u0026lt;String, Object\u0026gt; laRacine = new HashMap\u0026lt;\u0026gt;();  this.setRacine(laRacine);   List\u0026lt;Object\u0026gt; lesVehicules = new ArrayList\u0026lt;\u0026gt;();  laRacine.put(\u0026#34;vehicules\u0026#34;, lesVehicules);   Map\u0026lt;String, Object\u0026gt; vehicule01 = new HashMap\u0026lt;\u0026gt;();  lesVehicules.add(vehicule01);   vehicule01.put(\u0026#34;nombreDeRoues\u0026#34;, 2);  vehicule01.put(\u0026#34;type\u0026#34;, \u0026#34;mobilette\u0026#34;);   Map\u0026lt;String, Object\u0026gt; etat01 = new HashMap\u0026lt;\u0026gt;();  vehicule01.put(\u0026#34;etat\u0026#34;, etat01);   etat01.put(\u0026#34;kilometrage\u0026#34;,14.45);  etat01.put(\u0026#34;besoinChangementHuile\u0026#34;,false);   Map\u0026lt;String, Object\u0026gt; vehicule02 = new HashMap\u0026lt;\u0026gt;();  lesVehicules.add(vehicule02);   vehicule02.put(\u0026#34;nombreDeRoues\u0026#34;, 4);  vehicule02.put(\u0026#34;type\u0026#34;, \u0026#34;camion\u0026#34;);   Map\u0026lt;String, Object\u0026gt; etat02 = new HashMap\u0026lt;\u0026gt;();  vehicule02.put(\u0026#34;etat\u0026#34;, etat02);   etat02.put(\u0026#34;kilometrage\u0026#34;,13344.5);  etat02.put(\u0026#34;besoinChangementHuile\u0026#34;,true);  } } "},{"id":33,"href":"/arbres/","title":"Comprendre les arbres","section":"Code les cartes!","content":"Chapitre 5: Comprendre les arbres #  "},{"id":34,"href":"/arbres/generique/","title":"Arbre générique","section":"Comprendre les arbres","content":"Section 5.1: Arbre générique #  "},{"id":35,"href":"/arbres/binaire/","title":"Arbre binaire","section":"Comprendre les arbres","content":"Section 5.2: Arbre binaire #  "},{"id":36,"href":"/mappages/","title":"Comprendre les mappages","section":"Code les cartes!","content":"Chapitre 6: Comprendre les mappages #  "},{"id":37,"href":"/conclusion/","title":"Conclusion","section":"Code les cartes!","content":"Conclusion #  "},{"id":38,"href":"/modelisation/_brouillons/pile_appel/","title":"Pile d'appel","section":"Modélisation des données et limitations de l'approche","content":"Pile d\u0026rsquo;appel #   C\u0026rsquo;est quand une methode() fait un appel à elle-même :  public void methode(){  /* ... */    methode();    /* ... */ }   Le résultat est une boucle\n  Plusieurs algorithmes sont plus faciles à coder de cette façon\n c\u0026rsquo;est souvent plus proche de la définition papier (mathématique)    Par exemple :\n  définition mathématique de la fonction factorielle :\n fac(0) = 1 fac(n) = n * fac(n-1)    code Java récursif :\n    public int factoriel(int n){  if(n == 0){   return 1;   }else{   return n * factoriel(n-1);  } }   NOTE : le prof ignore volontairement le guide de style en faisant deux return\n  Il est toujours possible de transformer des appels récursifs en boucle normale\n  public int factoriel(int n){  int resultat;   if(i == 0){   resultat = 1;   }else{   resultat = n;   for(int i = n-1; i \u0026gt; 0; i--){  resultat = resulat * i;  }   }   return resultat; }  NOTE : on voit comment la code est plus loin de la définition mathématique  %!s().1 Pile d\u0026rsquo;appel #    La récursivité utilise la pile d\u0026rsquo;appels pour mémoriser des valeurs\n  Qu\u0026rsquo;est-ce que la pile d\u0026rsquo;appels?\n quand on fait un appel de méthode, les arguments sont stoqués sur la pile quand la méthode termine, c\u0026rsquo;est retiré de la pile la pile permet de revenir là où on était dans la méthode précédente    Par exemple :\n  public static void A(int x, int y){   B(\u0026#34;a\u0026#34;); }  public static void B(String c){   C(new char[]{\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;}); }  public static void C(char[] tab){  }  public static void main(String[] args){   A(0,1);   // La pile va être  //  // au début: main()  // appel de A: main(), A(0,1)  // appel de B: main(), A(0,1), B(\u0026#34;a\u0026#34;)  // appel de C: main(), A(0,1), B(\u0026#34;a\u0026#34;), C({\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;})  // retour de C: main(), A(0,1), B(\u0026#34;a\u0026#34;)  // retour de B: main(), A(0,1)  // retour de A: main() }   En cas de plantage, la pile d\u0026rsquo;appel est affichée (équivalent de la ligne 24) :\n Exception in thread \u0026quot;main\u0026quot; java.lang.RuntimeException at Pile.C(Pile.java:15) at Pile.B(Pile.java:11) at Pile.A(Pile.java:6) at Pile.main(Pile.java:20)    %!s().2 Avantages de la récursivité #    Code souvent plus simple et plus lisible\n  Les boucles infinies sont détectées par des erreurs de débordement de pile\n  en anglais : stack overflow\n Exception in thread \u0026quot;main\u0026quot; java.lang.StackOverflowError at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) at Pile.A(Pile.java:6) ...      %!s().3 Inconvénient de la récursivité #    Plus facile d\u0026rsquo;écrire des boucles infinies (condition d\u0026rsquo;arrêt implicite)\n  En pratique, la pile d\u0026rsquo;appel est assez petite (p.ex. 1000 appels)\n donc souvent impossible d\u0026rsquo;utiliser la récursivité sur des gros problèmes    %!s().4 Transformer en boucle normale #    On peut transformer n\u0026rsquo;importe quelle méthode récursive en boucle\n  On peut écrire du code récursif pour un prototype\n et éliminer la récursivité pour le code de production    Certains compilateurs peuvent éliminer automatiquement la récursivité\n à condition que l\u0026rsquo;appel récursif soit la toute dernière instruction de la méthode    public int factoriel(int n){  return factoriel(n, 1); }  public int factoriel(int n, int courant){  if(n == 0){   return courant;   }else{   return factoriel(n-1, n * courant);  } } "},{"id":39,"href":"/bibliographie/","title":"Bibliographie","section":"Code les cartes!","content":"Bibliographie #    Data Structures : {fundamental tools}. (2022, 29 décembre). Dans Wikibooks. https://en.wikibooks.org/wiki/Data_Structures \n   Mayfield, C. et Downey, A. (2020). Think Java : How to Think Like a Computer Scientist (2e éd.). Open Textbook Library. https://open.umn.edu/opentextbooks/textbooks/285 \n   "},{"id":40,"href":"/annexes/annexe_grand_o/","title":"Annexe 1: la notation grand O","section":"Annexes","content":"La notation grand O #  À venir.\nPour l\u0026rsquo;instant, voir (« Data Structures :{fundamental tools} », 2022), en particulier le chapitre 2.\n"},{"id":41,"href":"/annexes/annexe_acceder_exemples/","title":"Annexe 2: accéder aux exemples","section":"Annexes","content":"Annexe 2: accéder aux exemples #  Préalables #   JDK 11 ou plus récent (testé jusqu\u0026rsquo;à JDK18) Git Eclipse  Cloner les sources #  Dans un GitBash (ou à la console en Linux ou Mac)\n$ git clone https://github.com/cartesjava/ca.ntro.cards.git Exécuter deplacer_decaler #  Dans un GitBash à la racine du dépôt git ca.ntro.cards\n$ sh gradlew shift_solution:generer # pour générer les cas de tests $ sh gradlew shift_solution:procedure # pour lancer l\u0026#39;outil de validation Utiliser l\u0026rsquo;outil de validation pour sélectionner le cas de test qui vous intéresse.\nLe modèle en JSON sera dans :\n solutions/shift_solution/_storage/models  Le graphe d\u0026rsquo;objets sera dans :\n solutions/shift_solution/_storage/graphs  Exécuter fibonacci #  $ sh gradlew fibonacci_solution:generer # pour générer les cas de tests $ sh gradlew fibonacci_solution:procedure # pour lancer l\u0026#39;outil de validation Utiliser l\u0026rsquo;outil de validation pour sélectionner le cas de test qui vous intéresse.\nLe modèle en JSON sera dans :\n solutions/fibonacci_solution/_storage/models  Le graphe d\u0026rsquo;objets sera dans :\n solutions/fibonacci_solution/_storage/graphs  Exécuter validator_cartesjava #  $ sh gradlew validator_cartesjava_solution:generer # pour générer les cas de tests $ sh gradlew validator_cartesjava_solution:valider # pour valider les modèles Utiliser l\u0026rsquo;outil de validation pour sélectionner le cas de test qui vous intéresse.\nLes modèles en JSON seront dans :\n solutions/validator_cartesjava_solution/_storage/models  Les graphes d\u0026rsquo;objets seront dans :\n solutions/validator_cartesjava_solution/_storage/graphs  Modifier une solution #  Générer les projets Eclipse avec\n$ sh gradlew eclipse Importer les projets en Eclipse afin de modifier le code\nEn particulier :\n Dans chaque projet _solution, modifier le modèle, p.ex.  pour deplacer_decaler : MonTableau pour fibonacci : MonCalculateur pour validator_cartesjava : les classes du paquet models    "},{"id":42,"href":"/annexes/annexe_programmer_exemple/","title":"Annexe 3: programmer un nouvel exemple","section":"Annexes","content":"Annexe 3: programmer un nouvel exemple #  Préalables #   JDK 11 ou plus récent (testé jusqu\u0026rsquo;à JDK18) Git Eclipse  Cloner les sources #  Dans un GitBash (ou à la console en Linux ou Mac)\n$ git clone https://github.com/cartesjava/ca.ntro.cards.git Créer un nouveau projet #  Pour créer une nouvelle visualisation avec les cartes :\n$ sh scripts/new_project.sh MonProjet mon_projet Pour créer un nouveau validateur :\n$ sh scripts/new_validator.sh MesModeles mes_modeles Créer et importer les projets Eclipse #  Générer les projets Eclipse avec\n$ sh gradlew eclipse Importer les projets en Eclipse\nModifier la visualisation avec les cartes #  S\u0026rsquo;inspirer des projets shift_procedure et fibonacci_procedure\nDans le projet mon_projet_procedure, modifier le paquet models\nRenommer au besoin la classe MonProjetCardsModel\nImplanter les méthodes marquées d\u0026rsquo;un TODO et que l\u0026rsquo;outil de validation utilise :\n copyDataFrom : copier les données d\u0026rsquo;un autre modèle compareToSolution : valider si le modèle courant est une solution updateViewDataImpl : afficher les cartes correspondant au modèle courant initializeAsTestCase : données de départ d\u0026rsquo;un cas de test  Finalement, modifier aussi test_cases.MonProjetTestCaseDatabase, en particulier :\n describeTestCasesToGenerate : faire la liste des cas de tests à générer  Ajouter des modèles à un validateur #  Dans le projet validator_mes_modeles, modifier le paquet models\nS\u0026rsquo;inspirer de Model01 et Model01SuperClass pour voir comment créer un nouveau modèle\nNe pas oublier d\u0026rsquo;implanter la méthode copyDataFrom qui est utilisé par l\u0026rsquo;outil copier un modèle.\n"},{"id":43,"href":"/annexes/annexe_modifier_manuel/","title":"Annexe 4: suggérer une modification à ce manuel","section":"Annexes","content":"Comment modifier ce manuel #  Obtenir les sources #  Le dépôt source est ici : https://github.com/cartesjava/cartesjava.github.io\nSuggérer une modification #    Au bas de la page à modifier, cliquer sur Modifier cette page\n  Se connecter à GitHub\n  La première fois uniquement\n  « forker » le dépôt\n    Modifier le source de la page directement dans votre navigateur\n  Décrire votre modification (commentaire de commit)\n  Créer un « pull request » pour communiquer votre suggestion au propriétaire du dépôt d\u0026rsquo;origine\n  Étape 1\n  Étape 2\n    Attendre que le propriétaire du dépôt d\u0026rsquo;origine évalue votre suggestion\n  Modifier le manuel en local #    Installer Hugo sur votre machine\n  Faire la commande suivante pour cloner le dépôt Git\n$ git clone https://github.com/cartesjava/cartesjava.github.io.git   La racine de ce dépôt Git est le répertoire contenant les fichiers suivants:\n├── archetypes ├── assets ├── config.yaml ├── content ├── docs ├── .git ├── .gitignore ├── i18n ├── layouts ├── nodes ├── parametres01.png ├── parametres02.png ├── parametres03.png ├── README.md ├── resources ├── scripts ├── src └── static   Pour ouvrir un GitBash à la racine du dépôt Git, faire\n  Démarrer un explorateur de fichier Windows\n  Naviguer jusqu\u0026rsquo;à la racine de dépôt Git\n  Clic-droit =\u0026gt; GitBash here\n    Démarrer Hugo à la racine du dépôt Git cartesjava.github.io\n$ hugo server   Naviguer vers localhost:1313\n  Voici les fichiers et répertoires importants\n├── assets # répertoire avec les .css ├── config.yaml # configuration du site ├── content # sources pour le contenu │ ├── annexes │ ├── approche │ ├── arbres │ ├── bibliographie │ ├── conclusion │ ├── efficacite │ ├── _index.md │ ├── intro │ ├── listes │ ├── mappages │ ├── modelisation │ ├── preface │ └── procedures ├── docs # fichiers .html pour publication ├── src # sources pour les extensions à Hugo └── static # images et fichiers statiques   Modifier directement la version publique de ce manuel #    Vous devez avoir les droits en écriture pour le dépôt Git\n  Voir le README sur la page Web du dépôt :\n  https://github.com/cartesjava/cartesjava.github.io    "},{"id":44,"href":"/annexes/annexe_ateliers/","title":"Annexe 5: exemples d'ateliers","section":"Annexes","content":"Annexe 5: exemples d\u0026rsquo;ateliers #  "},{"id":45,"href":"/annexes/annexe_bilans/","title":"Annexe 6: bilans","section":"Annexes","content":"Annexe 6: bilans #  "},{"id":46,"href":"/mappages/arbre/","title":"Mappage avec arbre","section":"Comprendre les mappages","content":"Section 6.3: Mappage avec arbre #  "}]